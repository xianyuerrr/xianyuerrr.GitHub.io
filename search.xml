<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Array、ArrayList、LinkedList、Vector</title>
    <url>/2020/11/02/Array%E3%80%81ArrayList%E3%80%81LinkedList%E3%80%81Vector/</url>
    <content><![CDATA[<h2 id="Array、ArrayList、LinkedList、Vector">Array、ArrayList、LinkedList、Vector</h2>
<h3 id="Array-与-ArrayList">Array 与 ArrayList</h3>
<ol>
<li>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象</li>
<li>Array 是固定大小的，而 ArrayList 大小是自动扩展的</li>
<li>ArrayList 内置方法多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有</li>
</ol>
<h3 id="Arraylist-与-LinkedList">Arraylist 与 LinkedList</h3>
<ol>
<li>都不是线程安全的</li>
<li>ArrayList 为<strong>动态数组</strong>，而 LinkedList 为<strong>双向链表</strong></li>
<li>ArrayList 会存在一定的空间浪费，因为每次扩容都是之前的 1.5 倍；LinkedList 中的每个元素都要存放 前驱、后继、数据 三部分，所以每个元素的存储都比 ArrayList 花费更多的空间</li>
<li>ArrayList 比 LinkedList 在<strong>随机访问</strong>的时候效率要高</li>
<li>增加和删除操作，LinkedList 要比 ArrayList 效率要高</li>
<li>ArrayList 适合多读少增删的场景；LinkedList 适合多增删少读写的场景</li>
</ol>
<h3 id="ArrayList-与-Vector">ArrayList 与 Vector</h3>
<ol>
<li>Vector 使用 Synchronized 来实现线程同步，<strong>线程安全</strong>；但正因此，ArrayList 在<strong>性能</strong>方面要优于 Vector</li>
<li>都需要动态的调整容量，Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</li>
</ol>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer Plus(第六版)笔记</title>
    <url>/2020/11/30/C-Primer-Plus-%E7%AC%AC%E5%85%AD%E7%89%88-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1>C++ primer Plus 第六版</h1>
<h2 id="3-处理数据">3 处理数据</h2>
<h3 id="3-3-浮点数">3.3 浮点数</h3>
<h4 id="float">float</h4>
<p>1、c++的<strong>float</strong>：</p>
<ul>
<li>可以表示整数之间的值</li>
<li>有缩放因子，表示的范围大</li>
<li>运算慢、精度降低</li>
<li>只保证6位有效位</li>
</ul>
<h3 id="3-4-运算符">3.4 运算符</h3>
<h4 id="类型转换">类型转换</h4>
<p>1、c++<strong>类型转换</strong>：</p>
<ul>
<li>赋值给另一种类型的变量时</li>
<li>表达式包含不同类型时</li>
<li>传参给函数时</li>
</ul>
<p>2、数值转换<strong>潜在的问题</strong>：高精度类型转低精度类型可能会损失<strong>精度</strong></p>
<p>3、列表初始化不允许<strong>窄缩</strong>(narrowing)</p>
<h2 id="4-复合类型">4 复合类型</h2>
<h3 id="4-1-数组">4.1 数组</h3>
<p><strong>数组初始化</strong></p>
<p>1、只有在<strong>定义数组</strong>时可以使用初始化</p>
<p>2、只对数组的<strong>部分初始化</strong>时，其他元素将被设置位0</p>
<p>3、列表初始化：</p>
<ul>
<li>可省略等号</li>
<li>大括号内可为空（全为0）</li>
<li>禁止缩窄转换</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">double</span> earning[<span class="hljs-number">4</span>] &#123;&#125;;<br><span class="hljs-keyword">long</span> plifs[] &#123;<span class="hljs-number">25</span>, <span class="hljs-number">92</span>, <span class="hljs-number">3.0</span>&#125;;  <span class="hljs-comment">// not allowed</span><br></code></pre></td></tr></table></figure>
<h3 id="4-2-字符串">4.2 字符串</h3>
<p><strong>C-风格字符串</strong></p>
<p>1、以空字符（null character, 写作‘\0’, ASCLL码为0）结尾，空字符需要占一位。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">char</span> xianyue[<span class="hljs-number">5</span>] = &#123;<span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;\0&#x27;</span>&#125;;  <span class="hljs-comment">// a string!</span><br><span class="hljs-keyword">char</span> xianyue[<span class="hljs-number">5</span>] = <span class="hljs-string">&quot;xianyue&quot;</span>  <span class="hljs-comment">// 隐式空字符</span><br></code></pre></td></tr></table></figure>
<p>2、“S”不是字符常量，表示字符‘S’和‘\0’组成的字符串。实际上，“S”表示的是字符串所在的内存地址。</p>
<p><strong>字符串相关函数</strong></p>
<p>1、<strong>strlen()</strong>：返回存储在数组中的<strong>字符串</strong>（不包括空字符）的长度</p>
<p>2、<strong>sizeof()</strong>：返回<strong>整个数组</strong>的长度</p>
<p><strong>字符串输入</strong></p>
<p>1、<strong>cin</strong>使用空白（<strong>空格</strong>、<strong>制表符</strong>、<strong>换行符</strong>）来确定字符串的结束位置。这意味着<strong>cin</strong>在获取<strong>字符数组</strong>时只读取一个单词，剩余字符仍留在输入队列中</p>
<p>2、<strong>getchar()</strong>，从缓冲区拿取一个字符。</p>
<p>3、面向行的输入：</p>
<ul>
<li><strong>cin.getline(数组名, 读取字符数)</strong>，以换行符确定结尾（不保存换行符，存储时以空字符替代换行符）</li>
<li><strong>cin.get(数组名, 读取字符数)</strong>，不再丢弃换行符</li>
</ul>
<p>4、空行</p>
<h3 id="4-3-string">4.3 string</h3>
<p>string 可以自动调整长度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br>std::string str;<br></code></pre></td></tr></table></figure>
<p>不能将一个数组赋值给另一个数组，但是可以将一个<strong>string</strong>对象赋值给另一个<strong>string</strong>对象</p>
<p>6、原始字符串：字符表示的就是自己，用“(  )”来定界，“ 和 ( 间可以添加其他字符，作为强定界符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-string">R&quot;(&quot;str&quot;\n)&quot;</span><br></code></pre></td></tr></table></figure>
<h3 id="4-4-结构体">4.4 结构体</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 定义</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inflatable</span>&#123;</span><br>    <span class="hljs-keyword">char</span> name[<span class="hljs-number">20</span>];<br>    <span class="hljs-keyword">float</span> volume;<br>    <span class="hljs-keyword">double</span> price;<br>&#125;<br><br><span class="hljs-comment">// 声明,可以省略 struct</span><br>inflatable hat;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inflatable</span> <span class="hljs-title">hat</span>;</span><br><br><span class="hljs-comment">// 初始化，用逗号分隔值列表</span><br>inflatable a = &#123;<span class="hljs-string">&quot;xianyue&quot;</span>, <span class="hljs-number">1.88</span>, <span class="hljs-number">29.99</span>&#125;;<br><span class="hljs-comment">// C++11</span><br>inflatable a &#123;<span class="hljs-string">&quot;xianyue&quot;</span>, <span class="hljs-number">1.88</span>, <span class="hljs-number">29.99</span>&#125;;<br><span class="hljs-comment">// &#123;&#125;为空将导致每个字节都被设为0</span><br>inflatable a = &#123;&#125;;<br></code></pre></td></tr></table></figure>
<p>不允许<strong>缩窄</strong>转换。</p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>技术书籍阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 四种类型转换</title>
    <url>/2021/04/09/C-%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h1>C++四种类型转换</h1>
<h2 id="static-cast">static_cast</h2>
<p>是“静态转换”的意思，也就是在<strong>编译期间</strong>转换，转换失败的话会抛出一个编译错误。</p>
<p>用于良性转换，一般不会导致意外发生，风险很低。</p>
<p>需要注意的是，static_cast <strong>不能用于无关类型之间的转换</strong>，因为这些转换都是有风险的，例如：</p>
<ul>
<li>两个具体类型指针之间的转换，例如<code>int *</code>转<code>double *</code>、<code>Student *</code>转<code>int *</code>等。不同类型的数据存储格式不一样，长度也不一样，用 A 类型的指针指向 B 类型的数据后，会按照 A 类型的方式来处理数据：如果是读取操作，可能会得到一堆没有意义的值；如果是写入操作，可能会使 B 类型的数据遭到破坏，当再次以 B 类型的方式读取数据时会得到一堆没有意义的值。</li>
<li>int 和指针之间的转换。将一个具体的地址赋值给指针变量是非常危险的，因为该地址上的内存可能没有分配，也可能没有读写权限，恰好是可用内存反而是小概率事件。</li>
</ul>
<p>也不能用来去掉表达式的 const 修饰和 volatile 修饰</p>
<h2 id="const-cast">const_cast</h2>
<p>用于 const 与非 const、volatile 与非 volatile 之间的转换。换句话说，const_cast 就是用来将 const/volatile 类型转换为非 const/volatile 类型。</p>
<p>使用 const_cast 进行强制类型转换可以<strong>突破 C/C++ 的常数限制</strong>，修改常数的值，因此有一定的危险性；但是程序员如果这样做的话，基本上会意识到这个问题，因此也还有一定的安全性。</p>
<h2 id="reinterpret-cast">reinterpret_cast</h2>
<p>高度危险的转换，这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，但是可以实现最灵活的 C++ 类型转换。</p>
<p>reinterpret 是“重新解释”的意思，顾名思义，reinterpret_cast 这种转换<strong>仅仅是对二进制位的重新解释</strong>，不会借助已有的转换规则对数据进行调整，非常简单粗暴，所以风险很高。</p>
<p>reinterpret_cast 可以认为是 <strong>static_cast 的一种补充</strong>，一些 static_cast 不能完成的转换，就可以用 reinterpret_cast 来完成</p>
<h2 id="dynamic-cast">dynamic_cast</h2>
<p>dynamic_cast 与 static_cast 是相对的，dynamic_cast 是“动态转换”的意思，static_cast 是“静态转换”的意思。dynamic_cast 会在程序运行期间借助 RTTI 进行类型转换，这就要求基类必须包含虚函数；static_cast 在编译期间完成类型转换，能够更加及时地发现错误。</p>
<p>dynamic_cast 用于在类的<strong>继承层次</strong>之间进行类型转换，它既允许向上转型（Upcasting），也允许向下转型（Downcasting）。向上转型是无条件的，不会进行任何检测，所以都能成功；向下转型的前提必须是安全的，要借助 RTTI 进行检测，所有只有一部分能成功。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C++风格调用</span><br>xxx_cast&lt;new_type&gt;(data);<br><br><span class="hljs-comment">// 老式的C风格</span><br>(new_type)data;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 容器</title>
    <url>/2021/03/22/C-%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<p>C++容器</p>
<p>1、字符串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br></code></pre></td></tr></table></figure>
<p>2、常用函数</p>
<ol>
<li>
<p><strong>strlen()</strong>：返回存储在数组中的<strong>字符串</strong>（不包括空字符）的长度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">strlen</span>(字符数组)<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>sizeof()</strong>：返回<strong>整个数组</strong>的长度</p>
</li>
<li>
<p><strong>strcmp()</strong>：比较两个字符串的大小</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">strcmp</span>(字符数组<span class="hljs-number">1</span>, 字符数组<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>strcpy()</strong>：把一个字符串复制给另一个字符串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">strcpy</span>(字符数组<span class="hljs-number">1</span>, 字符数组<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>
<p>这里的复制包括 ‘\0’</p>
</li>
<li>
<p><strong>strcat()</strong>：字符串拼接</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">strcat</span>(字符数组<span class="hljs-number">1</span>, 字符数组<span class="hljs-number">2</span>);<br><span class="hljs-comment">// 将 2 拼接到 1 后面</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>sscanf()</strong> 格式输出（左 -&gt; 右）和 <strong>sprintf()</strong> 格式输出（右 -&gt; 左）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">sscanf</span>(str, <span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-built_in">sprintf</span>(str, <span class="hljs-string">&quot;%d&quot;</span>, n);<br></code></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ math 函数</title>
    <url>/2021/04/08/C-math-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1>C++常用 math 函数</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br></code></pre></td></tr></table></figure>
<ol>
<li><strong>abs(int i)</strong>：绝对值（整型）</li>
<li><strong>fabs(double x)</strong>：绝对值（实型）</li>
<li><strong>cabs(struct complex znum)</strong>：绝对值（复型）</li>
<li><strong>floor(double x)</strong>：向下取整</li>
<li><strong>ceil(double x)</strong>：向上取整</li>
<li><strong>pow(double r, double p)</strong>：幂运算 <img src="https://math.now.sh?inline=r%5Ep" style="display:inline-block;margin: 0;"/></li>
<li><strong>sqrt(double x)</strong>：算术平方根</li>
<li><strong>log(double x)</strong>：对数（以自然对数为底）</li>
<li><strong>log10(double num)</strong>：对数，以 10 为底</li>
<li><strong>sin(double x)</strong>、<strong>cos(double x)</strong>、<strong>tan(double x)</strong>：正弦、余弦、正切（弧度制，几分之几 <img src="https://math.now.sh?inline=%5Cpi" style="display:inline-block;margin: 0;"/>）</li>
<li><strong>asin(double x)</strong>、<strong>acos(double x)</strong>、<strong>atan(double x)</strong>：反正弦、反余弦、反正切（数值，比如 1）</li>
<li><strong>round(double x)</strong>：四舍五入</li>
<li><strong>double poly(double x,int degree,double coeffs [])</strong>：计算多项式</li>
</ol>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 刷题注意事项</title>
    <url>/2021/04/02/C-%E5%88%B7%E9%A2%98%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<ol>
<li>
<p>大数组定义位置</p>
<p><img src="https://raw.githubusercontent.com/xianyuerrr/PicGo/main/img/20210321201227.png" alt="image-20210321201227726"></p>
</li>
<li>
<p>以数组作为参数时，数组的第一维不需要填写长度。如果是二维，<strong>第二维需要填写长度</strong></p>
</li>
<li>
<p>函数</p>
<ol>
<li>
<p>memset</p>
<p>对数组中的每一个函数赋相同值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span> or #<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-built_in">memset</span>(数组名, 值, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(数组名));<br><span class="hljs-comment">// 只建议赋值为 0, 1（因为 memset 是按字节赋值）</span><br><span class="hljs-comment">// 如果要赋其他值，使用 fill（速度略慢）</span><br></code></pre></td></tr></table></figure>
</li>
<li></li>
</ol>
</li>
<li>
<p>在<strong>定义指针变量</strong>时，应该赋初值进行<strong>初始化</strong>，防止指针地址随机到系统工作区间</p>
</li>
<li>
<p>由于浮点数在计算机中的存储并不总是精确的，所以在比较时需要引入一个极小数 <strong>eps</strong> 来对这种误差进行修正（通常取 <img src="https://math.now.sh?inline=eps%3D10%5E%7B-8%7D%3D1e%5E%7B-8%7D" style="display:inline-block;margin: 0;"/>）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> eps = <span class="hljs-number">1e-8</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> Pi = <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1.0</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Equ(a, b) ((fabs((a)-(b))) &lt; (eps))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> More(a, b) (((a)-(b)) &gt; (eps))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Less(a, b) (((a)-(b)) &lt; (eps))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MoreEqu(a, b) (((a)-(b)) &gt; (-eps))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LessEqu(a, b) (((a)-(b)) &lt; (eps))</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>codeup</strong>1000题代码格式</p>
<ol>
<li>
<p>while-EOF 型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a, b;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b) != EOF) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, a + b);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>while-break型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a, b;<br>    <span class="hljs-comment">// 以 a, b 都为0为例</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b) != EOF) &#123;<br>        <span class="hljs-keyword">if</span> (a == <span class="hljs-number">0</span> &amp;&amp; b ==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, a + b);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">or</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a, b;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b), a || b) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, a + b);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>while(T - - )型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> T, a, b;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;T);<br>    <span class="hljs-keyword">while</span> (T--) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, a + b);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 输入输出</title>
    <url>/2020/11/06/C-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<h1>C++输入输出</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-comment">// 或者是</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br></code></pre></td></tr></table></figure>
<h2 id="scanf">scanf</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;格式控制&quot;</span>, 变量地址);<br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/xianyuerrr/PicGo/img/20210321182136.png" alt="image-20210321182129026"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xianyuerrr/PicGo/img/20210321182359.png" alt="image-20210321182359421"></p>
<h2 id="printf">printf</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;格式控制&quot;</span>, 变量名称);<br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/xianyuerrr/PicGo/img/20210321182608.png" alt="image-20210321182608018"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xianyuerrr/PicGo/img/20210321182624.png" alt="image-20210321182624557"></p>
<ol>
<li>
<p><strong>%md</strong></p>
<p>可以使不足 <strong>m</strong> 位的 <strong>int</strong> 型变量以 <strong>m</strong> 位进行右对齐输出，高位用空格不起补齐。长度超过 <strong>m</strong> 位则不起作用</p>
</li>
<li>
<p><strong>%0md</strong></p>
<p>与 <strong>%md</strong> 类似，只不过补空格变成了补 <strong>0</strong></p>
</li>
<li>
<p>%.mf</p>
<p>让浮点数保留 <strong>m</strong> 位小数输出（使用四舍五入成双规则）</p>
</li>
</ol>
<h2 id="getchar">getchar</h2>
<p>输入单个字符</p>
<h2 id="putchar">putchar</h2>
<p>输出单个字符</p>
<h2 id="gets">gets</h2>
<p>输入一行字符串（识别 ‘\n’作为输入结束）</p>
<p><strong>注意</strong>：scanf 完一个整数后，如果要使用 gets，需要先用 <strong>getchar</strong> 接收换行符</p>
<h2 id="puts">puts</h2>
<p>输出一行字符串，并紧跟一个换行</p>
<h2 id="cin">cin</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> spacename std;<br><span class="hljs-keyword">int</span> a;<br><span class="hljs-keyword">char</span> b[<span class="hljs-number">10</span>];<br>cin &gt;&gt; a;<br>cin.<span class="hljs-built_in">getline</span>(b, <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure>
<h2 id="cout">cout</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> spacename std;<br><span class="hljs-keyword">int</span> a;<br>cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>cout &lt;&lt; a &lt;&lt; endl;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>输入输出</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 标准库 STL</title>
    <url>/2021/06/20/C-%E6%A0%87%E5%87%86%E5%BA%93-STL/</url>
    <content><![CDATA[<h1>C++标准库STL</h1>
<h2 id="一、vector">一、vector</h2>
<p>向量，变长数组</p>
<p>可以以邻接表方式存储图（结点数太多的不行）</p>
<h3 id="1、定义">1、定义</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义</span><br>vector&lt;<span class="hljs-keyword">typename</span>&gt; name;<br>vector&lt;<span class="hljs-keyword">typename</span>&gt; arrayname[arraysize];<br><span class="hljs-comment">// 与vector&lt;vector&lt;int&gt; &gt;name;不同的是，这种写法的一维长度已经固定位arraysize，另一维才是变长的。</span><br><br><span class="hljs-comment">// typename可以是任何基本类型</span><br><span class="hljs-comment">// 也可以是STL标准容器，这种的要在定义时在 &gt;&gt; 符号之间加上空格（C++11之前的编译器会将其视为移位操作，导致编译错误）</span><br><br><span class="hljs-comment">// e.g.:</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt; name;<br>vector&lt;node&gt; name; <span class="hljs-comment">// node为结构体</span><br>vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; name; <span class="hljs-comment">// &gt;&gt;之间要加空格</span><br>vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; name;<br><br></code></pre></td></tr></table></figure>
<h3 id="2、访问">2、访问</h3>
<p>下标访问或通过迭代器访问</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-keyword">int</span>&gt; vi;<br>vector&lt;<span class="hljs-keyword">int</span>&gt;::iterator it = vi.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;::iterator it=vi.<span class="hljs-built_in">begin</span>();it!=vi.<span class="hljs-built_in">end</span>();it++)&#123;<br>4<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,*it);<br>&#125;<br><span class="hljs-comment">// vi[i] 和 *(vi.begin() + i) 是等价的</span><br><span class="hljs-comment">// 允许 i++， ++i</span><br></code></pre></td></tr></table></figure>
<p>在STL容器中，只有<strong>vector</strong>和<strong>string</strong>允许使用vi.begin()+4这种<strong>迭代器+整数</strong>的写法。</p>
<h3 id="3、常用函数">3、常用函数</h3>
<p><strong>1、push_back()</strong></p>
<p><code>push_back(x)</code>就是在vector后面添加一个元素x</p>
<p><strong>2、pop_back()</strong></p>
<p><code>pop_back(x)</code>用以删除vector的尾元素</p>
<p><strong>3、insert()</strong></p>
<p><code>insert(it, x)</code>用来向vector的任意迭代器it处插入一个元素x</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">vi.<span class="hljs-built_in">insert</span>(vi.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>);<br></code></pre></td></tr></table></figure>
<h2 id="二、set">二、set</h2>
<h3 id="1、定义-2">1、定义</h3>
<p><strong>内部自动有序</strong>且<strong>不含重复元素</strong>的容器。</p>
<p><strong>set</strong> 内的元素自动递增排序，且去除了重复元素</p>
<p><strong>延申</strong>：如果需要处理<strong>不唯一</strong>的情况，则需要使用 <strong>multiset</strong>.</p>
<p>C++11 标准还增加了 <strong>unordered_set</strong>，以散列代替set内部的红黑树(Red Black Tree，一种自平衡二叉查找树)实现，用来处理<strong>只去重但不排序</strong>的需求，<strong>速度</strong>比set快很多</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><br>set&lt;<span class="hljs-keyword">typename</span>&gt; name;<br><span class="hljs-comment">// e.g.</span><br>set&lt;<span class="hljs-keyword">int</span>&gt; name;<br>set&lt;node&gt; name;<br>set&lt;<span class="hljs-keyword">typename</span>&gt; Arrayname[arraySize];<br></code></pre></td></tr></table></figure>
<h3 id="2、访问-2">2、访问</h3>
<p>只能通过**迭代器(iterator)**访问</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">set&lt;<span class="hljs-keyword">typename</span>&gt;::iterator it;<br>set&lt;<span class="hljs-keyword">typename</span>&gt; st;<br><span class="hljs-keyword">for</span> (set&lt;<span class="hljs-keyword">typename</span>&gt;::iterator it = st.<span class="hljs-built_in">begin</span>(); it != st.<span class="hljs-built_in">end</span>(); it++)&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, *it)<br>&#125;<br><span class="hljs-comment">// 不能使用 it &lt; st.end() 的写法</span><br><span class="hljs-comment">// 除了vector 和 string 之外的STL容器都不支持 *(it+i) 的访问方式</span><br></code></pre></td></tr></table></figure>
<h3 id="3、常用函数-2">3、常用函数</h3>
<p><strong>1、insert()</strong></p>
<p><code>insert(x)</code> 可将 x 插入 set 容器，并自动<strong>递增排序</strong>和<strong>去重</strong>，时间复杂度为 <strong>O(logN)</strong></p>
<p><strong>2、find()</strong></p>
<p><code>find(vlaue)</code> 返回 set 中对应值为 value 的迭代器，时间复杂度为 <strong>O(logN)</strong></p>
<h2 id="三、string">三、string</h2>
<p>字符串容器，对字符串常用的功能进行了封装</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span> 与 <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-comment">// 是不同的</span><br></code></pre></td></tr></table></figure>
<h3 id="1、定义-3">1、定义</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">string str;<br>string str = <span class="hljs-string">&quot;xianyue&quot;</span>;<br></code></pre></td></tr></table></figure>
<h3 id="2、访问-3">2、访问</h3>
<ul>
<li>
<p>下标访问</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">string str = <span class="hljs-string">&quot;xianyue&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">length</span>(); i++) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, str[i]);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果要读入或者输出整个字符串，只能使用<strong>cin</strong>和<strong>cout</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">string str;<br>cin &gt;&gt; str;<br>cout &lt;&lt; str;<br></code></pre></td></tr></table></figure>
<p><strong>printf</strong>输出<strong>string</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">string str = <span class="hljs-string">&quot;xianyue&quot;</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, str.<span class="hljs-built_in">c_str</span>());<br><span class="hljs-comment">// 将string转成字符数组</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>迭代器访问</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">string str = <span class="hljs-string">&quot;xianyue&quot;</span>;<br><span class="hljs-keyword">for</span> (string::iterator it = str.<span class="hljs-built_in">begin</span>(); it != str.<span class="hljs-built_in">end</span>(); it++) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, *t);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>string</strong>和<strong>vector</strong>一样，支持直接对迭代器进行加减某个数字</p>
</li>
</ul>
<h3 id="3、常用函数-3">3、常用函数</h3>
<p><strong>1、operator+=</strong></p>
<p><strong>string</strong>的加法，拼接字符串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">string str1 = <span class="hljs-string">&quot;xianyue&quot;</span>, str2 = <span class="hljs-string">&quot;rrr&quot;</span>, str3;<br>str3 = str1 + str2;<br>cout&lt;&lt;str3;<br></code></pre></td></tr></table></figure>
<p><strong>2、compare operator</strong></p>
<p>两个<strong>string</strong>可以直接使用 <strong>==, !=, &lt;, &lt;=, &gt;, &gt;=</strong> 比较大小，规则是字典序</p>
<p><strong>3、length() / size()</strong></p>
<p>**length()**返回string的长度，即存放的字符数，O(1)</p>
<p>**size()<strong>和</strong>length()**基本相同</p>
<p><strong>4、insert()</strong>，O(N)</p>
<ul>
<li><strong>insert(pos, string)</strong>，在pos位置插入字符串 string</li>
<li><strong>insert(it, it2, it3)</strong>，<strong>it</strong>为原字符串的欲插入位置，<strong>it2</strong>和<strong>it3</strong>是待插入字符串的首尾迭代器</li>
</ul>
<p><strong>5、substr()</strong>，O(len)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">str.<span class="hljs-built_in">substr</span>(pos, len);<br><span class="hljs-comment">// 返回从 pos 号位开始，长度为 len 的子串</span><br></code></pre></td></tr></table></figure>
<p><strong>6、string::npos</strong>，是一个<strong>常数</strong>，本身的值为 <strong>-1</strong>，由于是 <strong>unsigned_int</strong> 类型，所以也可以当作 <strong>unsigned_int</strong> 的最大值。可以作为 <strong>find</strong> 函数失配时的返回值。</p>
<p><strong>7、find()</strong>，O(nm)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">str.<span class="hljs-built_in">find</span>(str2);<br><span class="hljs-comment">// 当 str2 是 str 的子串时，返回其在 str 中第一次出现的位置；</span><br><span class="hljs-comment">// 如果 str2 不是 str 的子串，返回 string::npos</span><br><br>str.<span class="hljs-built_in">find</span>(str2, pos);<br><span class="hljs-comment">// 从 pos 号位开始匹配 str2，返回值与上相同</span><br></code></pre></td></tr></table></figure>
<p><strong>8、replace()</strong>，O(str.length)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">str.<span class="hljs-built_in">replace</span>(pos, len, str2);<br><span class="hljs-comment">// 把 str 从 pos 号位开始，长度为 len 的子串替换为 str2</span><br><br>str.<span class="hljs-built_in">replace</span>(it1, it2, str2);<br><span class="hljs-comment">// 把 [it1, it2) 范围内的子串替换为 str2</span><br></code></pre></td></tr></table></figure>
<h2 id="四、map">四、map</h2>
<p><strong>映射</strong>，可以将任何基本类型映射到任何基本类型。内部是<strong>红黑树</strong>实现的（set也是），会以<strong>键</strong> <strong>从小到大</strong>的顺序自动排序。</p>
<p>如果一个键需要对应多个值，就只能用 <strong>multimap</strong>，C++11标准还增加了 <strong>unordered_map</strong>，以<strong>散列</strong>代替 map 内部的红黑树实现，<strong>只映射不排序</strong>，速度快得多</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br></code></pre></td></tr></table></figure>
<h3 id="1、定义-4">1、定义</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">map&lt;typename1, typename2&gt; mp;<br><br>map&lt;string, <span class="hljs-keyword">int</span>&gt; mp;<br><span class="hljs-comment">// 字符串到整型的映射，必须使用 string，而不能使用 char 数组</span><br><br>map&lt;set&lt;<span class="hljs-keyword">int</span>&gt;, string&gt; mp;<br></code></pre></td></tr></table></figure>
<h3 id="2、访问-4">2、访问</h3>
<ul>
<li>
<p>通过下标访问 <code>mp[key]</code></p>
</li>
<li>
<p>通过迭代器访问</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">map&lt;typename1, typename2&gt;::iterator it;<br>it-&gt;first; <span class="hljs-comment">// 访问 key</span><br>it-&gt;second; <span class="hljs-comment">// 访问 value</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3、常用函数-4">3、常用函数</h3>
<p><strong>1、find()</strong></p>
<p>find(key) 返回键为 key 的映射的迭代器，O(logN)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">map&lt;typename1, typename2&gt; mp;<br>map&lt;typename1, typename2&gt;::iterator it = mp.<span class="hljs-built_in">find</span>(key);<br></code></pre></td></tr></table></figure>
<h2 id="五、queue">五、queue</h2>
<p>队列，<strong>先进先出</strong>。</p>
<p><strong>双端队列</strong>：deque</p>
<p><strong>优先级队列</strong>：priority_queue</p>
<h3 id="1、定义-5">1、定义</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>queue&lt;<span class="hljs-keyword">typename</span>&gt; name;<br></code></pre></td></tr></table></figure>
<h3 id="2、访问-5">2、访问</h3>
<p>由于队列<strong>先进先出</strong>，所以只能通过 <code>front()</code> 来访问队首元素，或者是通过 <code>back()</code> 来访问队尾元素</p>
<h3 id="3、常用函数-5">3、常用函数</h3>
<p><strong>1、push()</strong></p>
<p><code>push(x)</code>，将 <code>x</code> 加入队列，O(1)</p>
<p><strong>2、front()、back()</strong></p>
<p><code>front() / back()</code> 获取 队首 / 队尾 元素，O(1)</p>
<p><strong>3、pop()</strong></p>
<p><code>pop()</code>，令队首元素出队，O(1)</p>
<p><strong>4、empty()</strong></p>
<p><code>empty()</code>，检测队列是否为空，O(1)</p>
<p><strong>注意</strong>：使用 <code>front() / pop()</code> 前， 必须使用 <code>empty()</code> 判断队列是否为空</p>
<h2 id="六、priority-queue">六、priority_queue</h2>
<p>优先级队列，底层是使用<strong>堆</strong>来进行实现的，队首元素一定是当前队列中优先级最高的</p>
<h3 id="1、定义-6">1、定义</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>priority_queue&lt;<span class="hljs-keyword">typename</span>&gt; name;<br><span class="hljs-comment">//对于基础类型 默认是大顶堆</span><br></code></pre></td></tr></table></figure>
<h3 id="2、访问-6">2、访问</h3>
<p>优先级队列没有 <code>front()</code> 函数 和 <code>back()</code> 函数，只能通过 <code>top()</code> 函数来访问队首元素（<strong>堆顶</strong>）</p>
<h3 id="3、常用函数-6">3、常用函数</h3>
<p><strong>1、push()</strong></p>
<p><code>push(x)</code>，令 x 入队，O(logN)</p>
<p><strong>2、top()</strong></p>
<p><code>top()</code>，获取队首元素，O(1)</p>
<p><strong>3、pop()</strong></p>
<p>堆顶出队</p>
<p><strong>4、empty()</strong></p>
<p>检测队列是否为空</p>
<h3 id="4、优先级设置">4、优先级设置</h3>
<p><strong>基本数据类型</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">priority_queue&lt;<span class="hljs-keyword">int</span>&gt; q; <span class="hljs-comment">// 默认为大顶堆</span><br>priority_queue&lt;<span class="hljs-keyword">int</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;, less&lt;<span class="hljs-keyword">int</span>&gt; &gt; q;<br><span class="hljs-comment">//     这里一定要有空格，不然成了右移运算符↓</span><br>priority_queue&lt;<span class="hljs-keyword">int</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt; &gt; c;<br><span class="hljs-comment">//这样就是小顶堆</span><br><span class="hljs-comment">// vector&lt;int&gt; 是承载底层数据结构堆（heap）的容器</span><br><span class="hljs-comment">// less&lt;int&gt; 是对第一个参数的比较类</span><br><span class="hljs-comment">// less&lt;int&gt; 表示数字越大优先级越高</span><br><span class="hljs-comment">// greater&lt;int&gt; 表示数字越小优先级越高</span><br></code></pre></td></tr></table></figure>
<p><strong>结构体</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fruit</span> &#123;</span><br>    string name;<br>    <span class="hljs-keyword">int</span> price;<br>    <span class="hljs-comment">// 重载运算符</span><br>    <span class="hljs-comment">// 价格高的优先级高</span><br>    <span class="hljs-comment">// 默认是值越小优先级越高</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> fruit &amp;f1,<span class="hljs-keyword">const</span> fruit &amp;f2) &#123;<br>        <span class="hljs-keyword">return</span> f1.price &lt; f2.price;<br>    &#125;<br>&#125;;<br>priority_queue&lt;fruit&gt; q;<br><span class="hljs-comment">// or</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmp</span> &#123;</span><br>    <span class="hljs-comment">// 价格高的优先级高</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> fruit &amp;f1, <span class="hljs-keyword">const</span> fruit &amp;f2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> f1.price &gt; f2.price;<br>    &#125;<br>&#125;;<br>priority_queue&lt;fruit, vector&lt;fruit&gt;, cmp&gt; q;<br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/xianyuerrr/PicGo/img/20210402230553.png" alt="image-20210402230545841"></p>
<p><strong>注意</strong>：使用 <code>top()</code> 函数前，必须使用 <code>empty()</code> 判断优先级队列是否为空</p>
<h2 id="七、stack">七、stack</h2>
<p>栈，<strong>后进先出</strong></p>
<h3 id="1、定义-7">1、定义</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>stack&lt;<span class="hljs-keyword">typename</span>&gt; name;<br></code></pre></td></tr></table></figure>
<h3 id="2、访问-7">2、访问</h3>
<p>由于栈是一种后进先出的数据结构，所以只能通过<code>top()</code> 来访问<strong>栈顶</strong>元素</p>
<h3 id="3、常用函数-7">3、常用函数</h3>
<p><strong>1、push()</strong></p>
<p><code>push(x)</code> 将<code>x</code>入栈，O(1)</p>
<p><strong>2、top()</strong>，获取栈顶元素，O(1)</p>
<p><strong>3、pop()</strong>，弹出栈顶元素，O(1)</p>
<p><strong>4、empty()</strong>：检测是否为空，O(1)</p>
<h2 id="八、pair">八、pair</h2>
<p>把两个元素绑在一起，但又不想定义结构体时，<strong>pair</strong>是一个替代品，也就是说<strong>pair</strong>可以看作一个内部有两个元素的结构体。</p>
<p><strong>map</strong>的内部实现涉及<strong>pair</strong>。可以作为<strong>map</strong> 的键值对来插入。</p>
<h3 id="1、定义-8">1、定义</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;utility&gt;</span> <span class="hljs-comment">// 可以使用 &lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>pair&lt;typename1, typename2&gt; name;<br><span class="hljs-function">pair&lt;typename1, typename2&gt; <span class="hljs-title">name</span><span class="hljs-params">(value1, value2)</span></span>;<br><br><span class="hljs-comment">// 临时构建</span><br>pair&lt;type1, type2&gt;(value1, value2);<br><span class="hljs-comment">// or</span><br><span class="hljs-built_in">make_pair</span>(value1, value2);<br></code></pre></td></tr></table></figure>
<h3 id="2、访问-8">2、访问</h3>
<p>pair只有两个元素，分别是 <strong>first</strong> 和 <strong>second</strong>，按正常结构体去访问就好</p>
<h3 id="3、常用函数-8">3、常用函数</h3>
<p><strong>比较操作数</strong>，以&lt;first, second&gt; 元组方式比较</p>
<h2 id="九、algorithm头文件下的常用函数">九、algorithm头文件下的常用函数</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br></code></pre></td></tr></table></figure>
<p><strong>1、max()、min()、abs()</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">max</span>(x, y);<br><span class="hljs-built_in">min</span>(x, y);<br><br><span class="hljs-built_in">abs</span>(x);<br><span class="hljs-comment">// x 只能是整数，浮点数的绝对值要使用 math 头文件下的 fabs(x)</span><br></code></pre></td></tr></table></figure>
<p><strong>2、swap()</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">swap</span>(x, y);<br><span class="hljs-comment">// 交换 x, y 的值</span><br></code></pre></td></tr></table></figure>
<p><strong>3、reverse()</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">reverse</span>(it, it2);<br><span class="hljs-comment">// 将数组指针在 [it, it2) 之间的元素</span><br><span class="hljs-comment">// 或者容器的迭代器在 [it, it2) 范围内元素</span><br><span class="hljs-comment">// 进行反转</span><br></code></pre></td></tr></table></figure>
<p><strong>4、next_permutation()</strong></p>
<p>给出一个序列在<strong>全排列</strong>中的下一个序列。到达最后一个时返回<code>flase</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">do</span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d%d%d\n&quot;</span>, a[<span class="hljs-number">0</span>], a[<span class="hljs-number">1</span>], a[<span class="hljs-number">2</span>]);<br>&#125; <span class="hljs-keyword">while</span>(<span class="hljs-built_in">next_permutation</span>(a, a+<span class="hljs-number">3</span>));<br></code></pre></td></tr></table></figure>
<p><strong>5、fill()</strong></p>
<p>可以把<strong>数组</strong>或<strong>容器</strong>中的某一段区间赋为某个值。和<strong>memset</strong>不太一样，<strong>fill</strong>可以赋范围内的所有值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">fill</span>(it, it2, value);<br><span class="hljs-comment">// it - (it2-1) 赋值为 vlaue</span><br></code></pre></td></tr></table></figure>
<p><strong>6、sort()</strong></p>
<p>排序函数，效率较高。一般不推荐<strong>C语言</strong>中的<code>qsort()</code>，因为其比较繁琐。</p>
<p><strong>sort</strong>规避了<strong>经典快排</strong>中可能出现的复杂度退化到 <strong>O(<img src="https://math.now.sh?inline=n%5E2" style="display:inline-block;margin: 0;"/>)</strong> 的极端情况。</p>
<p><strong>STL</strong>标准容器中，只有 <strong>vector</strong>、<strong>string</strong>、<strong>deque</strong>是可以使用 <strong>sort</strong>。因为像是 <strong>set</strong>、<strong>map</strong>这种内部是使用<strong>红黑树</strong>实现的，元素本身就有序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(首元素地址, 尾元素的下一个地址, 比较函数(非必填));<br><span class="hljs-comment">// 默认进行递增排序</span><br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a&gt;b;<br>    <span class="hljs-comment">// a&gt;b 时把 a 放在 b 前面</span><br>&#125;<br><br><span class="hljs-comment">// struct 数组的排序</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br>    <span class="hljs-keyword">int</span> x, y;<br>&#125;;<br><span class="hljs-comment">// 按 x 的值递减排序</span><br>node ssd[<span class="hljs-number">10</span>];<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node a, node b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a.x &gt; b.x;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>7、lower_bound() 和 upper_bound()</strong></p>
<p>需要在一个<strong>有序</strong>数组或者容器中使用。O(log(last-first))</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">lower_bound</span>(first, last, val);<br><span class="hljs-comment">// 返回 [first, last) 内第一个值大于等于 val 的元素的位置</span><br><span class="hljs-comment">// 数组返回指针</span><br><span class="hljs-comment">// 容器返回迭代器</span><br><br><span class="hljs-comment">// 如果不存在这样的元素，返回可以插入该元素的 指针 或 迭代器</span><br></code></pre></td></tr></table></figure>
<h2 id="公共函数">公共函数</h2>
<p><strong>1、clear()</strong></p>
<p><code>clear()</code>用来清空vector中的所有元素</p>
<p><strong>2、erase()</strong></p>
<p>erase()有两种用法：</p>
<ul>
<li>删除单个元素：erase(it)，删除迭代器处的元素</li>
<li>删除一个区间内的所有元素：<code>erase(first,last)</code>，即删除(first,last )区间内的元素</li>
</ul>
<p><strong>3、size()</strong></p>
<p><code>size()</code>用来获得vector中元素的个数</p>
<h2 id="C-11">C++11</h2>
<p><strong>emplace_front</strong>、<strong>emplace</strong> 和 <strong>emplace_back</strong></p>
<p>这些操作构造而不是拷贝元素到容器中，这些操作分别对应<strong>push_front</strong>、<strong>insert</strong> 和<strong>push_back</strong>，允许我们将元素放在容器头部、一个指定的位置和容器尾部</p>
<h3 id="两者的区别">两者的区别</h3>
<p>当调用insert时，是将对象传递给insert，对象被拷贝到容器中，而当我们使用emplace时，是将参数传递给构造函，emplace使用这些参数在容器管理的内存空间中直接构造元素。</p>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>Go基础</title>
    <url>/2021/11/05/Go%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1>Go</h1>
<h2 id="基础">基础</h2>
<h3 id="特征">特征</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">- 自带 gc<br>- 思想简单，没有继承、多态、类等<br>- 语法层支持并发<br></code></pre></td></tr></table></figure>
<h3 id="规范">规范</h3>
<p><strong>命名</strong></p>
<p>Go的函数、变量、常量、自定义类型、包<code>(package)</code>的命名方式遵循以下规则：</p>
<pre><code>1）首字符可以是任意的Unicode字符或者下划线
2）剩余字符可以是Unicode字符、下划线、数字
3）字符长度不限
</code></pre>
<p>以大写字母开头时，对象就可以被外部包的代码所使用；否则，对外部的包是不可见的。</p>
<p><strong>25个关键字</strong></p>
<pre><code>break、default、func、interface、select、case、defer、go、map 、struct、chan、else、goto、package、switch、const、fallthrough、if、range、type、continue、for、import、return、var
</code></pre>
<p><strong>37个保留字</strong></p>
<pre><code>Constants:    true  false  iota  nil

Types:    int  int8  int16  int32  int64  
         uint  uint8  uint16  uint32  uint64  uintptr
         float32  float64  complex128  complex64
         bool  byte  rune  string  error

Functions:   make  len  cap  new  append  copy  close  delete
             complex  real  imag
             panic  recover
</code></pre>
<p><strong>权限</strong></p>
<pre><code>1）声明在函数内部，是函数的本地值，类似private
2）声明在函数外部，是对当前包可见(包内所有.go文件都可见)的全局值，类似protect
3）声明在函数外部且首字母大写是所有包可见的全局值,类似public
</code></pre>
<h3 id="类型">类型</h3>
<p><strong>值类型</strong></p>
<pre><code>bool
int(32 or 64), int8, int16, int32(rune), int64
uint(32 or 64), uint8(byte), uint16, uint32, uint64
float32, float64
string
complex64, complex128
array    -- 固定长度的数组

默认值：
数值类型为 0，
布尔类型为 false，
字符串为 &quot;&quot;（空字符串）。
</code></pre>
<p><strong>引用类型</strong></p>
<pre><code>slice   -- 序列数组(最常用)
map     -- 映射
chan    -- 管道
</code></pre>
<p><strong>内置函数</strong></p>
<pre><code>append          -- 用来追加元素到数组、slice中,返回修改后的数组、slice
close           -- 主要用来关闭channel
delete            -- 从map中删除key对应的value
panic            -- 停止常规的goroutine  （panic和recover：用来做错误处理）
recover         -- 允许程序定义goroutine的panic动作
real            -- 返回complex的实部   （complex、real imag：用于创建和操作复数）
imag            -- 返回complex的虚部
make            -- 用来分配内存，返回Type本身(只能应用于slice, map, channel)
new                -- 用来分配内存，主要用来分配值类型，比如int、struct。返回指向Type的指针
cap                -- capacity是容量的意思，用于返回某个类型的最大容量（只能用于切片和 map）
copy            -- 用于复制和连接slice，返回复制的数目
len                -- 来求长度，比如string、array、slice、map、channel ，返回长度
print、println     -- 底层打印函数，在部署环境中建议使用 fmt 包
</code></pre>
<p><strong>内置接口</strong></p>
<pre><code>type error interface &#123; //只要实现了Error()函数，返回值为String的都实现了err接口

        Error()    String

&#125;
</code></pre>
<h3 id="init-和-main">init 和 main</h3>
<p><code>init</code>函数</p>
<ol>
<li>init函数是用于程序执行前做包的==初始化==的函数，比如初始化包里的变量等</li>
<li>每个包可以拥有==多个==init函数</li>
<li>包的每个源文件也可以拥有多个init函数</li>
<li>init函数==不能被其他函数调用==，而是==在main函数执行之前==，自动被调用</li>
</ol>
<p>执行顺序：</p>
<ol>
<li>==同一文件==的<code>init()</code>调用顺序是==从上到下==的。</li>
<li>对==同一package==中不同文件是按文件名字符串比较“==从小到大==”顺序调用各文件中的<code>init()</code>函数。</li>
<li>对于不同<code>package</code>，如果不相互依赖的话，按照main包中”先<code>import</code>的后调用”的顺序调用其包中的<code>init()</code>，如果<code>package</code>存在依赖，则先调用最早被依赖的<code>package</code>中的<code>init()</code>，最后调用<code>main</code>函数。、</li>
<li>如果<code>init</code>函数中使用了<code>println()</code>或者<code>print()</code>你会发现在执行过程中这两个不会按照你想象中的顺序执行。这两个函数官方只推荐在测试环境中使用，对于正式环境不要使用。</li>
</ol>
<p>相同点：两个函数在定义时不能有任何的参数和返回值，且是自动调用。</p>
<p>不同点：init可以应用于任意包中，且可以重复定义多个；main函数只能用于main包中，且只能定义一个。</p>
<h3 id="命令">命令</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">go env用于打印Go语言的环境信息。<br><br>go run命令可以编译并运行命令源码文件。<br><br>go get可以根据要求和实际情况从互联网上下载或更新指定的代码包及其依赖包，并对它们进行编译和安装。<br><br>go build命令用于编译我们指定的源码文件或代码包以及它们的依赖包。<br><br>go install用于编译并安装指定的代码包及它们的依赖包。<br><br>go clean命令会删除掉执行其它命令时产生的一些文件和目录。<br><br>go doc命令可以打印附于Go语言程序实体上的文档。我们可以通过把程序实体的标识符作为该命令的参数来达到查看其文档的目的。<br><br>go test命令用于对Go语言编写的程序进行测试。<br><br>go list命令的作用是列出指定的代码包的信息。<br><br>go fix会把指定代码包的所有Go语言源码文件中的旧版本代码修正为新版本的代码。<br><br>go vet是一个用于检查Go语言源码中静态错误的简单工具。<br><br>go tool pprof命令来交互式的访问概要文件的内容。<br></code></pre></td></tr></table></figure>
<h3 id="package">package</h3>
<ul>
<li>文件夹名与包名没有直接关系，并非需要一致。</li>
<li>同一个文件夹下的文件只能有一个包名，否则编译报错。</li>
</ul>
<p>当前的调试部分可以使用 <strong>go run filename.go</strong> 来执行。</p>
<p>可以生成一个 <strong><a href="http://build.sh">build.sh</a></strong> 脚本，用于在指定位置产生已编译好的 可执文件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#!/usr/bin/env bash<br><br>CURRENT_DIR=`pwd`<br>OLD_GO_PATH=&quot;$GOPATH&quot;  #例如: /usr/local/go<br>OLD_GO_BIN=&quot;$GOBIN&quot;    #例如: /usr/local/go/bin<br><br>export GOPATH=&quot;$CURRENT_DIR&quot; <br>export GOBIN=&quot;$CURRENT_DIR/bin&quot;<br><br>#指定并整理当前的源码路径<br>gofmt -w src<br><br>go install test_hello<br><br>export GOPATH=&quot;$OLD_GO_PATH&quot;<br>export GOBIN=&quot;$OLD_GO_BIN&quot;<br></code></pre></td></tr></table></figure>
<h3 id="变量">变量</h3>
<p><strong>方式一</strong>，指定类型</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">var identifier type # 不初始化，系统赋为默认值<br>var identifier type = value<br><span class="hljs-meta">#</span><span class="bash"> 一次声明多个</span><br>var identifier1, identifier2 type<br>var identifier1, identifier2 type = value1, value2<br><span class="hljs-meta">#</span><span class="bash"> 数值型默认为 0</span><br><span class="hljs-meta">#</span><span class="bash"> bool 默认为 <span class="hljs-literal">false</span></span><br><span class="hljs-meta">#</span><span class="bash"> string 默认为 <span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-meta">#</span><span class="bash"> 其它 默认为 nil</span><br></code></pre></td></tr></table></figure>
<p><strong>方式二</strong>，根据值自行判断类型</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">var v_name = value<br></code></pre></td></tr></table></figure>
<p><strong>方式三</strong>，<code>:=</code>，如果已经使用 var 声明过，使用此方式会产生编译错误</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">v_name := value<br><span class="hljs-meta">#</span><span class="bash"> intVal := 1</span><br><span class="hljs-meta">#</span><span class="bash"> 相当于 :</span> <br><span class="hljs-meta">#</span><span class="bash"> var intVal</span><br><span class="hljs-meta">#</span><span class="bash"> intVal = 1</span><br></code></pre></td></tr></table></figure>
<p><strong>多变量声明</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">var (<br>    vname1 v_type1<br>    vname2 v_type2<br>)<br><span class="hljs-meta">#</span><span class="bash"> 一般用于声明全局变量</span><br></code></pre></td></tr></table></figure>
<h3 id="常量">常量</h3>
<p>常量中的数据类型只可以是==布尔型==、==数字型==（整数型、浮点型和复数）和==字符串型==。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">const identifier [type] = value<br><span class="hljs-meta">#</span><span class="bash"> 可以省略类型说明符 <span class="hljs-built_in">type</span></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 显式类型定义：</span> <br>const b string = &quot;abc&quot;<br><span class="hljs-meta">#</span><span class="bash"> 隐式类型定义：</span> <br>const b = &quot;abc&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 多个相同类型的声明</span><br>const c_name1, c_name2 = value1, value2<br></code></pre></td></tr></table></figure>
<p>常量可以用作<strong>枚举</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">const (<br>    Unknown = 0<br>    Female = 1<br>    Male = 2<br>)<br></code></pre></td></tr></table></figure>
<p>常量表达式中，函数必须是==内置函数==，否则编译不过</p>
<p><strong>iota</strong></p>
<p>iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中==每新增一行常量声明==将使 iota 计数一次(iota 可理解为 ==const 语句块中的行索引==)。</p>
<p>iota 可以被用作枚举值：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">const (<br>    a = iota<br>    b = iota<br>    c = iota<br>)<br><span class="hljs-meta">#</span><span class="bash"> 可简写为：</span><br>const (<br>    a = iota<br>    b # 与上方最近的语句内容相同<br>    c<br>)<br></code></pre></td></tr></table></figure>
<h3 id="数组">数组</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">var variable_name [SIZE] variable_type<br>var balance [10] float32<br><br>var balance = [5] float32 &#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;<br>var balance = [...] float32 &#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 将索引为 1 和 3 的元素初始化</span><br>var balance = [5] float32 &#123;1:2.0,3:7.0&#125;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 多维数组</span><br>var variable_name [SIZE1][SIZE2]...[SIZEN] variable_type<br>var threedim [5][10][4] int<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP和HTTPS</title>
    <url>/2021/08/14/HTTP%E5%92%8CHTTPS/</url>
    <content><![CDATA[<h1>HTTP 和 HTTPS</h1>
<h2 id="HTTP">HTTP</h2>
<p>使用<strong>TCP</strong></p>
<p>HTTP 最重要也是最突出的优点是 <strong>简单、灵活、易于扩展</strong>。</p>
<p>因为 HTTP 协议本身不属于一种语言，它并不限定某种编程语言或者操作系统，所以天然具有<strong>跨语言、跨平台</strong>的优越性。</p>
<p><strong>无状态</strong>，每个请求都是完全独立的，简单，不需要使用状态机</p>
<p>无状态其实既是优点又是缺点。因为服务器没有记忆能力，所以就不需要额外的资源来记录状态信息，不仅实现上会简单一些，而且还能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。</p>
<p>既然服务器没有记忆能力，它就无法支持需要连续多个步骤的<code>事务</code>操作。每次都得问一遍身份信息，不仅麻烦，而且还增加了不必要的数据传输量。由此出现了 <code>Cookie</code> 技术。</p>
<p><strong>明文传输</strong>，不安全</p>
<p><strong>no-cache</strong>：必须先与服务器确认返回的响应是否被更改，然后才能使用该响应来满足后续对同一个网址的请求。</p>
<p>**no-store：**所有内容都不会被缓存或 Internet 临时文件中</p>
<h3 id="Cookie与Session">Cookie与Session</h3>
<p>Cookie带来的问题：</p>
<p>1.每次页面请求都会把cookies往服务器上送一次，<strong>浪费了带宽</strong>；</p>
<p>2.状态数据<strong>存放在浏览器上太危险</strong>了，而且Cookies在HTTP请求中是以明文传输的。</p>
<p>3.Cookie的<strong>大小</strong>限制在4KB, 对于复杂的状态数据显然不够用。</p>
<p>主流的做法是：</p>
<p>1、浏览器向HTTP服务器发出第一个请求时，服务器分配一个SessionID, 存入浏览器的Cookies中。这个SessionID一般是一个类似于GUID的字符串，几十个字节，也不多。</p>
<p>2、<strong>服务器上维持一个会话状态数据库</strong>（也可能是个内存表），用SessionID作为标识存放每一个会话的状态信息。</p>
<p>3、每一次浏览器发出请求时，都将这个SessionID向服务器提交一次，便于服务器根据它获得之前的会话数据，写入新的会话数据。</p>
<h2 id="HTTPS">HTTPS</h2>
<h3 id="对称加密与非对称加密">对称加密与非对称加密</h3>
<p>对称加密：加密与解密使用同一个密钥</p>
<p>优缺点：算法公开，计算量小，加密速度快、效率高；但由于加密解密都使用同一个密钥，而由于信道是不安全的，导致其不安全。</p>
<p>非对称加密：双方各有自己的公钥与私钥，使用公钥加密将发送的信息，使用私钥解密接收到的信息。只在信道上沟通用于加密的公钥，由于解密的私钥未曾在信道上传输，所以私钥是安全的，也即非对称加密是安全的。</p>
<p>优缺点：算法复杂，安全性高；但同时也由于其算法复杂，导致效率低下</p>
<p><img src="https://raw.githubusercontent.com/xianyuerrr/PicGo/main/img/20210914161130.png" alt="image-20210914161127660"></p>
<h3 id="HTTPS采用的加密方式">HTTPS采用的加密方式</h3>
<p>由于对称加密不安全，非对称加密</p>
<p>HTTPS采用对称与非对称结合的加密方式，这种方式看似安全实则不然。在没有引入证书之前，这种对称与非对称结合的加密方式也并非是传输安全的。</p>
<p>他无法防范这种中间人攻击，中间人可以轻而易举的获取其沟通所得的对称密钥。</p>
<p>而其之所以不安全，是因为<strong>客户端不知道，这把公钥是不是服务器的</strong>。解决这个问题的方式就是使用数字证书。</p>
<p><img src="https://raw.githubusercontent.com/xianyuerrr/PicGo/main/img/20210914160828.png" alt="image-20210914160825223"></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计网</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Object类的方法</title>
    <url>/2019/10/05/Java-Object%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="Java-Object类的方法">Java-Object类的方法</h2>
<p>Object有以下方法：</p>
<p><img src="https://raw.githubusercontent.com/xianyuerrr/PicGo/main/img/202110051049327.png" alt="Object类的方法"></p>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 格式化输出</title>
    <url>/2020/11/30/C-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<h1>c++格式化输出</h1>
<p><a href="http://c.biancheng.net/view/275.html">http://c.biancheng.net/view/275.html</a></p>
<p>1、在头文件 <strong>iomanip</strong> 中定义</p>
<p>保留<strong>ans</strong>位小数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><br>cout &lt;&lt; <span class="hljs-built_in">setiosflags</span>(ios::fixed) &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">2</span>) &lt;&lt; ans &lt;&lt; endl;<br></code></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>流操纵算子</th>
<th>作  用</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>*dec</td>
<td>以十进制形式输出整数</td>
<td>常用</td>
</tr>
<tr>
<td>hex</td>
<td>以十六进制形式输出整数</td>
<td></td>
</tr>
<tr>
<td>oct</td>
<td>以八进制形式输出整数</td>
<td></td>
</tr>
<tr>
<td>fixed</td>
<td>以普通小数形式输出浮点数</td>
<td></td>
</tr>
<tr>
<td>scientific</td>
<td>以科学计数法形式输出浮点数</td>
<td></td>
</tr>
<tr>
<td>left</td>
<td>左对齐，即在宽度不足时将填充字符添加到右边</td>
<td></td>
</tr>
<tr>
<td>*right</td>
<td>右对齐，即在宽度不足时将填充字符添加到左边</td>
<td></td>
</tr>
<tr>
<td>setbase(b)</td>
<td>设置输出整数时的进制，b=8、10 或 16</td>
<td></td>
</tr>
<tr>
<td>setw(w)</td>
<td>指定输出宽度为 w 个字符，或输人字符串时读入 w 个字符</td>
<td></td>
</tr>
<tr>
<td>setfill©</td>
<td>在指定输出宽度的情况下，输出的宽度不足时用字符 c 填充（默认情况是用空格填充）</td>
<td></td>
</tr>
<tr>
<td>setprecision(n)</td>
<td>设置输出浮点数的精度为 n。  在使用非 fixed 且非 scientific 方式输出的情况下，n 即为有效数字最多的位数，如果有效数字位数超过 n，则小数部分四舍五人，或自动变为科学计 数法输出并保留一共 n 位有效数字。  在使用 fixed 方式和 scientific 方式输出的情况下，n 是小数点后面应保留的位数。</td>
<td></td>
</tr>
<tr>
<td>setiosflags(flag)</td>
<td>将某个输出格式标志置为 1</td>
<td></td>
</tr>
<tr>
<td>resetiosflags(flag)</td>
<td>将某个输出格式标志置为 0</td>
<td></td>
</tr>
<tr>
<td>boolapha</td>
<td>把 true 和 false 输出为字符串</td>
<td>不常用</td>
</tr>
<tr>
<td>*noboolalpha</td>
<td>把 true 和 false 输出为 0、1</td>
<td></td>
</tr>
<tr>
<td>showbase</td>
<td>输出表示数值的进制的前缀</td>
<td></td>
</tr>
<tr>
<td>*noshowbase</td>
<td>不输出表示数值的进制.的前缀</td>
<td></td>
</tr>
<tr>
<td>showpoint</td>
<td>总是输出小数点</td>
<td></td>
</tr>
<tr>
<td>*noshowpoint</td>
<td>只有当小数部分存在时才显示小数点</td>
<td></td>
</tr>
<tr>
<td>showpos</td>
<td>在非负数值中显示 +</td>
<td></td>
</tr>
<tr>
<td>*noshowpos</td>
<td>在非负数值中不显示 +</td>
<td></td>
</tr>
<tr>
<td>*skipws</td>
<td>输入时跳过空白字符</td>
<td></td>
</tr>
<tr>
<td>noskipws</td>
<td>输入时不跳过空白字符</td>
<td></td>
</tr>
<tr>
<td>uppercase</td>
<td>十六进制数中使用 A~E。若输出前缀，则前缀输出 0X，科学计数法中输出 E</td>
<td></td>
</tr>
<tr>
<td>*nouppercase</td>
<td>十六进制数中使用 a~e。若输出前缀，则前缀输出 0x，科学计数法中输出 e。</td>
<td></td>
</tr>
<tr>
<td>internal</td>
<td>数值的符号（正负号）在指定宽度内左对齐，数值右对 齐，中间由填充字符填充。</td>
<td></td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>输入输出</tag>
      </tags>
  </entry>
  <entry>
    <title>Java垃圾回收</title>
    <url>/2021/09/29/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<h1>Java 垃圾回收</h1>
<p>垃圾回收，顾名思义就是释放垃圾占用的空间，从而提升程序性能，防止内存泄露。当一个对象不再被需要时，该对象就需要被回收并释放空间。</p>
<p>Java 内存运行时数据区域包括程序计数器、虚拟机栈、本地方法栈、堆等区域。其中，程序计数器、虚拟机栈和本地方法栈都是线程私有的，当线程结束时，这些区域的生命周期也结束了，因此不需要过多考虑回收的问题。而堆是虚拟机管理的内存中最大的一块，堆中的内存的分配和回收是动态的，垃圾回收主要关注的是堆空间。</p>
<h2 id="调用垃圾回收器的方法">调用垃圾回收器的方法</h2>
<p>调用垃圾回收器的方法是 gc，该方法在 System 类和 Runtime 类中都存在。</p>
<p>在 Runtime 类中，方法 gc 是实例方法，方法 System.gc 是调用该方法的一种传统而便捷的方法。</p>
<p>在 System 类中，方法 gc 是静态方法，该方法会调用 Runtime 类中的 gc 方法。</p>
<p>其实，java.lang.System.gc 等价于 java.lang.Runtime.getRuntime.gc 的简写，都是调用垃圾回收器。</p>
<p>方法 gc 的作用是提示 Java 虚拟机进行垃圾回收，该方法由系统自动调用，不需要人为调用。该方法被调用之后，由 Java 虚拟机决定是立即回收还是延迟回收。</p>
<h2 id="finalize-方法">finalize 方法</h2>
<p>与垃圾回收有关的另一个方法是 finalize 方法。该方法在 Object 类中被定义，在释放对象占用的内存之前会调用该方法。该方法的默认实现不做任何事，如果必要，子类应该重写该方法，一般建议在该方法中释放对象持有的资源。</p>
<h2 id="判断对象是否可回收">判断对象是否可回收</h2>
<p>垃圾回收器在对堆进行回收之前，首先需要确定哪些对象是可回收的。常用的算法有两种，引用计数算法和根搜索算法。</p>
<h3 id="引用计数算法">引用计数算法</h3>
<p>引用计数算法给每个对象添加引用计数器，用于记录对象被引用的计数，引用计数为 0 的对象即为可回收的对象。</p>
<p>虽然引用计数算法的实现简单，判定效率也很高，但是引用计数算法无法解决对象之间循环引用的情况。如果多个对象之间存在循环引用，则这些对象的引用计数永远不为 0，无法被回收。因此 Java 语言没有使用引用计数算法。</p>
<h3 id="根搜索算法">根搜索算法</h3>
<p>主流的商用程序语言都是使用根搜索算法判断对象是否可回收。根搜索算法的思路是，从若干被称为 GC Roots 的对象开始进行搜索，不能到达的对象即为可回收的对象。</p>
<p>在 Java 中，GC Roots 一般包含下面几种对象：</p>
<p>虚拟机栈中引用的对象；</p>
<p>本地方法栈中的本地方法引用的对象；</p>
<p>方法区中的类静态属性引用的对象；</p>
<p>方法区中的常量引用的对象。</p>
<h3 id="引用的分类">引用的分类</h3>
<p>引用计数算法和根搜索算法都需要通过判断引用的方式判断对象是否可回收。</p>
<p>在 JDK 1.2 之后，Java 将引用分成四种，按照引用强度从高到低的顺序依次是：强引用、软引用、弱引用、虚引用。</p>
<p><strong>强引用</strong>是指在程序代码中普遍存在的引用。垃圾回收器永远不会回收被强引用关联的对象。</p>
<p><strong>软引用</strong>描述还有用但并非必需的对象。只有在系统将要发生内存溢出异常时，被软引用关联的对象才会被回收。在 JDK 1.2 之后，提供了 SoftReference 类实现软引用。</p>
<p><strong>弱引用</strong>描述非必需的对象，其强度低于软引用。被弱引用关联的对象只能存活到下一次垃圾回收发生之前，当垃圾回收器工作时，被弱引用关联的对象一定会被回收。在 JDK 1.2 之后，提供了 WeakReference 类实现弱引用。</p>
<p><strong>虚引用</strong>是最弱的引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。在 JDK 1.2 之后，提供了 PhantomReference 类实现虚引用。</p>
<h2 id="垃圾回收算法">垃圾回收算法</h2>
<h3 id="标记—清除算法">标记—清除算法</h3>
<p>标记—清除算法是最基础的垃圾回收算法，后续的垃圾收集算法都是基于标记—清除算法进行改进而得到的。标记—清除算法分为“标记”和“清除”两个阶段，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</p>
<p>标记—清除算法有两个主要缺点。一是效率问题，标记和清除的效率都不高，二是空间问题，标记清除之后会产生大量不连续的内存碎片，导致程序在之后的运行过程中无法为较大对象找到足够的连续内存。</p>
<h3 id="复制算法">复制算法</h3>
<p>复制算法是将可用内存分成大小相等的两块，每次只使用其中的一块，当用完一块内存时，将还存活着的对象复制到另外一块内存，然后把已使用过的内存空间一次清理掉。</p>
<p>复制算法解决了效率问题。由于每次都是对整个半区进行内存回收，因此在内存分配时不需要考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可。复制算法的优点是实现简单，运行高效，缺点是将内存缩小为了原来的一半，以及在对象存活率较高时复制操作的次数较多，导致效率降低。</p>
<h3 id="标记—整理算法">标记—整理算法</h3>
<p>标记—整理算法是根据老年代的特点提出的。标记过程与标记—清除算法一样，但后续步骤不是直接回收被标记的对象，而是让所有存活的对象都向一端移动，然后清除边界以外的内存。</p>
<h3 id="分代收集算法">分代收集算法</h3>
<p>分代收集算法根据对象的存活周期不同将内存划分为多个区域，对每个区域选用不同的垃圾回收算法。</p>
<p>一般把 Java 堆分为新生代和老年代。在新生代中，大多数对象的生命周期都很短，因此选用<strong>复制</strong>算法。在老年代中，对象存活率高，因此选用标记—清除算法或<strong>标记—整理</strong>算法。</p>
<h2 id="分配内存与回收策略">分配内存与回收策略</h2>
<p>Java 堆可以分成新生代和老年代，新生代又可以细分成 Eden 区、From Survivor 区、To Survivor 区等。对于不同的对象，有相应的内存分配规则。</p>
<h3 id="Minor-GC-和-Full-GC">Minor GC 和 Full GC</h3>
<p>Minor GC 指发生在新生代的垃圾回收操作。因为大多数对象的生命周期都很短，因此 Minor GC 会频繁执行，一般回收速度也比较快。</p>
<p>Full GC 也称 Major GC，指发生在老年代的垃圾回收操作。出现了 Full GC，经常会伴随至少一次的 Minor GC。老年代对象的存活时间长，因此 Full GC 很少执行，而且执行速度会比 Minor GC 慢很多。</p>
<h3 id="对象优先在-Eden-区分配">对象优先在 Eden 区分配</h3>
<p>大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。</p>
<h3 id="大对象直接进入老年代">大对象直接进入老年代</h3>
<p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。大对象对于虚拟机的内存分配而言是坏消息，经常出现大对象会导致内存还有不少空间时就提前触发垃圾回收以获取足够的连续空间分配给大对象。</p>
<p>将大对象直接在老年代中分配的目的是避免在 Eden 区和 Survivor 区之间出现大量内存复制。</p>
<h3 id="长期存活的对象进入老年代">长期存活的对象进入老年代</h3>
<p>虚拟机采用分代收集的思想管理内存，因此需要识别每个对象应该放在新生代还是老年代。虚拟机给每个对象定义了年龄计数器，对象在 Eden 区出生之后，如果经过第一次 Minor GC 之后仍然存活，将进入 Survivor 区，同时对象年龄变为 1，对象在 Survivor 区每经过一次 Minor GC 且存活，年龄就增加 1，增加到一定阈值时则进入老年代（阈值默认为 15）。</p>
<h3 id="动态对象年龄判定">动态对象年龄判定</h3>
<p>为了能更好地适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到阈值才能进入老年代。如果在 Survivor 区中相同年龄的所有对象的空间总和大于 Survivor 区空间的一半，则年龄大于或等于该年龄的对象直接进入老年代。</p>
<h3 id="空间分配担保">空间分配担保</h3>
<p>在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的空间总和，如果这个条件成立，那么 Minor GC 可以确保是安全的。</p>
<p>只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。</p>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的线程创建</title>
    <url>/2020/10/31/Java%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[<h1>Java 的线程创建</h1>
<h2 id="1-线程创建">1. 线程创建</h2>
<p><strong>方法一：</strong> 实现<strong>Runnable</strong>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.sun.tools.javac.Main;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@auther</span> xianyue</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/10/30 - 星期五 - 23:43</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><span class="hljs-comment">//    实现**Runnable**接口</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        Demo01 th1 = <span class="hljs-keyword">new</span> Demo01();<br>        th1.start();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;我在学习多线程&quot;</span>+i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;线程运行了&quot;</span>+ (i+<span class="hljs-number">10</span>));<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//    运行结果如下：</span><br><span class="hljs-comment">//    我在学习多线程0</span><br><span class="hljs-comment">//            我在学习多线程1</span><br><span class="hljs-comment">//    线程运行了10</span><br><span class="hljs-comment">//            我在学习多线程2</span><br><span class="hljs-comment">//    线程运行了11</span><br><span class="hljs-comment">//            线程运行了12</span><br><span class="hljs-comment">//    我在学习多线程3</span><br><span class="hljs-comment">//            线程运行了13</span><br><span class="hljs-comment">//    我在学习多线程4</span><br><span class="hljs-comment">//            线程运行了14</span><br><span class="hljs-comment">//    我在学习多线程5</span><br><span class="hljs-comment">//            线程运行了15</span><br><span class="hljs-comment">//    我在学习多线程6</span><br><span class="hljs-comment">//            线程运行了16</span><br><span class="hljs-comment">//    线程运行了17</span><br><span class="hljs-comment">//            线程运行了18</span><br><span class="hljs-comment">//    我在学习多线程7</span><br><span class="hljs-comment">//            线程运行了19</span><br><span class="hljs-comment">//    我在学习多线程8</span><br><span class="hljs-comment">//            我在学习多线程9</span><br></code></pre></td></tr></table></figure>
<h2 id="方法二：-继承-Thread-类">方法二： 继承 Thread 类</h2>
<p>Thread类实现了Runnable接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@auther</span> xianyue</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/10/30 - 星期五 - 23:35</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-comment">//    继承Thread类</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.run();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;线程运行了&quot;</span>+ (i+<span class="hljs-number">10</span>));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Demo01 th1 = <span class="hljs-keyword">new</span> Demo01();<br>        th1.start();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;我在学习多线程&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//    运行结果如下：</span><br><span class="hljs-comment">//    我在学习多线程0</span><br><span class="hljs-comment">//            我在学习多线程1</span><br><span class="hljs-comment">//    线程运行了10</span><br><span class="hljs-comment">//            我在学习多线程2</span><br><span class="hljs-comment">//    线程运行了11</span><br><span class="hljs-comment">//            我在学习多线程3</span><br><span class="hljs-comment">//    线程运行了12</span><br><span class="hljs-comment">//            我在学习多线程4</span><br><span class="hljs-comment">//    线程运行了13</span><br><span class="hljs-comment">//            我在学习多线程5</span><br><span class="hljs-comment">//    线程运行了14</span><br><span class="hljs-comment">//            我在学习多线程6</span><br><span class="hljs-comment">//    线程运行了15</span><br><span class="hljs-comment">//            我在学习多线程7</span><br><span class="hljs-comment">//    线程运行了16</span><br><span class="hljs-comment">//            线程运行了17</span><br><span class="hljs-comment">//    我在学习多线程8</span><br><span class="hljs-comment">//            线程运行了18</span><br><span class="hljs-comment">//    我在学习多线程9</span><br><span class="hljs-comment">//            线程运行了19</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//进程已结束，退出代码 0</span><br><br><br></code></pre></td></tr></table></figure>
<h2 id="方法三：实现-Callable-接口">方法三：实现 Callable 接口</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.sun.tools.javac.Main;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@auther</span> xianyue</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/10/30 - 星期五 - 23:43</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span> </span>&#123;<br><span class="hljs-comment">//    实现**Runnable**接口</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        Demo01 th1 = <span class="hljs-keyword">new</span> Demo01();<br>        th1.start();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;我在学习多线程&quot;</span>+i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//    运行结果如下：</span><br><span class="hljs-comment">//    我在学习多线程0</span><br><span class="hljs-comment">//            线程运行了10</span><br><span class="hljs-comment">//    我在学习多线程1</span><br><span class="hljs-comment">//            线程运行了11</span><br><span class="hljs-comment">//    我在学习多线程2</span><br><span class="hljs-comment">//            线程运行了12</span><br><span class="hljs-comment">//    我在学习多线程3</span><br><span class="hljs-comment">//            线程运行了13</span><br><span class="hljs-comment">//    我在学习多线程4</span><br><span class="hljs-comment">//            线程运行了14</span><br><span class="hljs-comment">//    我在学习多线程5</span><br><span class="hljs-comment">//            线程运行了15</span><br><span class="hljs-comment">//    线程运行了16</span><br><span class="hljs-comment">//            线程运行了17</span><br><span class="hljs-comment">//    线程运行了18</span><br><span class="hljs-comment">//            线程运行了19</span><br><span class="hljs-comment">//    我在学习多线程6</span><br><span class="hljs-comment">//            我在学习多线程7</span><br><span class="hljs-comment">//    我在学习多线程8</span><br><span class="hljs-comment">//            我在学习多线程9</span><br></code></pre></td></tr></table></figure>
<p>不论以什么方式实现多线程，都要重写**Run()**方法，编写线程所执行的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">*斜体文本*<br>_斜体文本_<br>**粗体文本**<br>__粗体文本__<br>***粗斜体文本***<br>___粗斜体文本___<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 复习</title>
    <url>/2020/10/13/Java-%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1>JavaReStudy</h1>
<h2 id="总览">总览</h2>
<p>重学Java的记录</p>
<ul>
<li>Java 基础</li>
<li>数据结构类</li>
<li>IO</li>
<li>注解和反射</li>
<li>多线程</li>
</ul>
<h2 id="Java-基础">Java 基础</h2>
<h3 id="对-Java-平台的理解">对 Java 平台的理解</h3>
<ul>
<li>跨平台，通过 JVM 和 字节码 这种抽象，屏蔽了操作系统和硬件的细节，做到了书写一次，到处运行</li>
<li>垃圾收集，不需要自己操心内存的分配</li>
</ul>
<p>Java 是解释和编译并存的语言。Java 源代码首先通过 Javac 编译成字节码(bytecode)，然后在运行时通过 Java 虚拟机(JVM) 内嵌的解释器将字<br>
节码转换为最终的 机器码。</p>
<p>但是常见的 JVM，比如 Oracle JDK 提供的 Hotspot JVM，都会提供 JIT(Just in Time) 编译器，也就是动态编译器。能够在运行时将热点代码 (<br>
运行时频率很高的那部分代码，根据二八定律，这部分代码虽然代码量不大，但系统 80% 以上的时间都在执行这段代码) 编译成机器码，<br>
这部分热点代码就属于 <strong>编译执行</strong> 了，依此来提高效率。</p>
<h3 id="Exception-和-Error-的区别">Exception 和 Error 的区别</h3>
<p>两者都继承了 Throwable 类，可以被抛出 (throw) 和 捕获 (catch)。Exception 和 Error 体现了 Java 设计者对异常情况的分类。</p>
<ul>
<li>Exception 是指在正常运行中，可以预料的意外情况，应该被捕获并进行相应处理。</li>
<li>Error 是指在正常情况下，不太可能出现的情况，绝大部分的 Error 都会导致程序处于非正常的、不可恢复的状态。所以不便于也不需要捕获，<br>
比如 OutOfMemoryError 之类。</li>
</ul>
<p>而 Exception 又分为 <strong>可检查</strong> 和 <strong>不可检查</strong> 两种异常。可检查异常必须在源码里显示地进行捕获处理，不然不能通过编译。<br>
不可检查异常就是所谓的 <strong>运行时异常</strong>，比如 NullPointerException</p>
<p><img src="https://cdn.jsdelivr.net/gh/xianyuerrr/PicGo/img/D:/xianyue/Desktop/Snipaste_2021-11-17_00-13-03.png" alt="Exception 和 Error"></p>
<h3 id="final-finally-finalize">final, finally, finalize</h3>
<ul>
<li>final 可以原来修饰类、方法、变量，分别有不同的作用。</li>
</ul>
<p>final 修饰的 class 不可被继承，final 修饰的方法不可被重写(override)，final 修饰的变量不能被修改。</p>
<p>很多核心类库以及第三方类库的源码中，相当一部分都被声明为 final class，可以有效避免使用者更改基础功能，以保证平台安全。<br>
使用 final 修饰参数或者变量时，可以保护只读数据，省去一些防御性拷贝的必要</p>
<ul>
<li>finally 是 Java 保证重点代码一定要被执行的一种机制。</li>
</ul>
<p>可以使用 try-finally 或者 try-catch-finally 来进行类似关闭 JDBC 连接、保证 unlock 锁等动作</p>
<ul>
<li>finalize 是 java.lang.Object 的一个方法，设计目的是保证对象在被垃圾回收前完成特定资源的回收，但现在已经不推荐使用，在 JDK9 被<br>
标记为 deprecated</li>
</ul>
<h3 id="强、软、弱、虚-四种引用">强、软、弱、虚 四种引用</h3>
<p>不同的引用类型，主要体现的是对象不同的可达性(reachable)状态和对垃圾收集的影响。</p>
<ul>
<li>强引用(strong reference)，就是最常见的普通对象引用，只要还有强引用指向一个对象，那么这个对象就“活着”，不会被当作垃圾回收。</li>
<li>软引用(soft reference)，是相对强引用弱化一些的引用，可以让对象豁免垃圾回收，在 JVM 认为内存不足时才会进行回收，以防止 OOM(OutOfMemoryError)</li>
<li>弱引用(weak reference)，不能豁免垃圾回收，只是提供一种访问在弱引用状态下的对象的途径，是很多缓存实现的选择。</li>
<li>虚引用，也叫幻象引用，不能通过它来访问对象。仅仅是提供一种确保对象被 finalize 以后，做某些事情的机制，比如 Post-Mortem 清理机制<br>
、Java 平台自身 Cleaner 机制</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xianyuerrr/PicGo/img/D:/xianyue/Desktop/%E5%8F%AF%E8%BE%BE%E6%80%A7%E7%BA%A7%E5%88%AB.png" alt="可达性级别"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xianyuerrr/PicGo/img/Roaming/Typora/typora-user-images/image-20211121000621424.png" alt="image-20211121000621424"></p>
<h3 id="String、StringBuffer、StringBuilder">String、StringBuffer、StringBuilder</h3>
<p>String 是 Java 非常基础的类，提供了构造和管理字符串的各种基本逻辑。是典型的 Immutable 类，final class，所有属性也都是 final 的,<br>
无法对其内部进行修改。由于 Immutable 对象不可变，所以在拷贝构造时不需要额外复制数据。类似拼接、裁剪字符串都会产生 <strong>新的 String 对象</strong>。</p>
<p>StringBuffer 解决了使用 String 进行拼接字符串时会产生太多中间对象的问题。它本质上是一个线程安全的 <strong>可修改字符序列</strong>。其通过把各种<br>
修改数据的方法都直接 <strong>加上 synchronized 关键字</strong> 来实现。但其在线程安全的同时也带来了额外的性能开销。所以除非有线程安全的需要，<br>
不然还是推荐使用 StringBuilder，它和 StringBuffer 相比去掉了线程安全的部分，在保障功能的同时，有效减小了开销，是绝大部分情况下进<br>
行字符串拼接的首选。</p>
<p>StringBuffer 和 StringBuilder 底层都是利用可修改的（char，JDK9 以后是 byte）数组，都继承了 AbstractStringBuilder，<br>
里面包含了基本操作，区别仅在于方法是否加了 synchronized。</p>
<p>另外，这个内部数组应该创建成多大的呢？太小的话会在拼接时 <strong>重新创建足够大的数组</strong>；如果太大，又会浪费空间。<br>
目前的实现是，构建 <strong>初始字符串长度加16</strong> 长度的数组。如果我们确定会发生多次拼接，而且大概是可预计的，那就可以指定合适的大小，<br>
避免多次扩容的开销。</p>
<p>JDK1.8 中，虽然 String 是标准的不可变类，但是其 hash值 并没有使用 final 修饰，其 hash值 是在第一次调用 hashcode 方法时计算，<br>
但是此方法未加锁，变量也没有使用 volatile 修饰以保证其可见性。当有多个线程调用的时候，<br>
hash值 可能会被计算多次（注意，多次计算的结果是一样的）。</p>
<h3 id="动态代理">动态代理</h3>
<p>动态类型 与 静态类型 的区别在于：语言类型信息的检查是发生在 <strong>运行时</strong> 还是 <strong>编译期</strong>。</p>
<p>强类型 与 弱类型 的区别在于：不同类型变量赋值时，是否需要 <strong>显式（强制）进行类型转换</strong>。</p>
<p>通常认为，Java 是静态的强类型语言，但由于其提供了反射等机制，也具备了部分动态类型语言的能力。</p>
<p>动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是使用类似机制做到的，<br>
比如用来包装 RPC 调用、面向切面编程（AOP）。</p>
<p>实现动态代理的方式有很多，比如 JDK 自身提供的动态代理，主要利用了反射机制。还有其他的实现方式，比如利用字节码操作机制，<br>
类似 ASM、cglib、Javassit 等</p>
<p>动态代理，首先是一个代理机制。代理可以看作是对调用目标的一个包装，通过代理可以让调用者和实现者之间 <strong>解耦</strong>。比如进行 RPC 的调用、<br>
框架内部的寻址、序列化、反序列化等。通过代理，可以提供更加友好的界面。</p>
<h3 id="int-和-Integer">int 和 Integer</h3>
<p>boolean, byte, short, char, int, float, double, long 是 Java 的八大原始数据类型。Java 虽然号称一切皆对象，但原始数据类型除外。</p>
<p>由于原始数据类型不能与 Java 泛型配合使用，所以对其进行了封装。<br>
Integer 是 int 的包装类，有一个 int 类型的字段存储数据，而且提供了基本操作。Java 可以根据上下文，自动进行转换。</p>
<p>根据实践，大部分的数据操作都集中在较小的数值范围。因此，在 Java 5 中新增了静态工厂方法 valueOf，<br>
在调用它时会利用缓存机制（默认为 -128 - 127，可以自行调整，缓存里的数据都是 <strong>private final</strong> 的）。</p>
<p>对象包括：</p>
<ul>
<li>
<p>对象头<br>
一般为 16 字节，包括两部分。<br>
第一部分有哈希码、锁状态标志、线程持有的锁、偏向线程 id、gc 分代年龄等。<br>
第二部分是类型指针，指向对象对应 class 对象的内存地址。</p>
</li>
<li>
<p>对象实例</p>
</li>
<li>
<p>对齐填充</p>
</li>
</ul>
<p>自动装箱/拆箱是 Java 平台为保证不同写法在运行时等价而自动进行的一些转换，发生在 <strong>编译阶段</strong>，生成的字节码是一致的。</p>
<p>原则上，要避免 <strong>无意义的装箱、拆箱</strong>，尤其是在对性能敏感的场合，不管是内存使用还是处理速度，当对象数量变多时都相差极大。</p>
<h3 id="Vector、ArrayList、LinkedList">Vector、ArrayList、LinkedList</h3>
<p>三者都是集合框架中的 List，功能类似但表现有很大不同。</p>
<ul>
<li>
<p>Vector<br>
<strong>线程安全</strong>的动态数组，如果不需要线程安全，不建议选择。扩容时会提高 1 倍。</p>
</li>
<li>
<p>ArrayList<br>
与 Vector 相似，本身不是线程安全的，性能会好很多。扩容时会提高 0.5 倍。</p>
</li>
<li>
<p>LinkedList<br>
双向链表，线程不安全，不需要调整容量。</p>
</li>
</ul>
<p>Vector 和 ArrayList 为动态数组，适合随机访问的场合。除了尾部插入和删除，往往性能会比较差。LinkedList 进行插入、删除要高效的多，<br>
但是随机访问性能较差。</p>
<h3 id="HashTable、HashMap、TreeMap">HashTable、HashMap、TreeMap</h3>
<img src="https://cdn.jsdelivr.net/gh/xianyuerrr/PicGo/img/Roaming/Typora/typora-user-images/image-20211210233744397.png" alt="image-20211210233744397" style="zoom: 67%;" />
<ul>
<li>HashTable 本身是同步的，不支持 null 键和值，由于开销较大，一般不推荐使用。</li>
<li>HashMap 与 HashTable 大体一致，但它是不同步的，而且支持 null 键和值。</li>
<li>TreeMap 基于红黑树，提供顺序访问，它的 get、put、remove 之类操作都是 O(log(n))的复杂度，具体顺序可以由指定的 Comparator 决定，或者根据键的自然顺序来判断。</li>
</ul>
<p>HashMap 在并发环境可能出现 无限循环占用 CPU、size 不准确等诡异问题。HashMap 的性能表现非常依赖于哈希码的有效性。</p>
<p>Set 的几种实现:</p>
<p>TreeSet 支持自然顺序访问，但是添加、删除、包含等操作要相对低效（log(n) 时间）。</p>
<p>HashSet 则是利用哈希算法，理想情况下，如果哈希散列正常，可以提供常数时间的添加、删除、包含等操作，但是它不保证有序。</p>
<p>LinkedHashSet，内部构建了一个记录插入顺序的双向链表，因此提供了按照插入顺序遍历的能力，与此同时，也保证了常数时间的添加、删除、<br>
包含等操作，这些操作性能略低于 HashSet，因为需要维护链表的开销。</p>
<p>在遍历元素时，HashSet 性能受自身容量影响，所以初始化时，除非有必要，<br>
不然不要将其背后的 HashMap 容量设置过大。而对于 LinkedHashSet，由于其内部链表提供的方便，遍历性能只和元素多少有关系。</p>
<h3 id="线程安全，ConcurrentHashMap">线程安全，ConcurrentHashMap</h3>
<p>Java 提供了不同层面的线程安全支持。除了 HashTable 等同步内容，还提供了所谓的<strong>同步包装器</strong>(Synchronized Wrapper)，但是他们的锁粒度非常粗，在高并发情况下，性能比较低下。更加普遍的选择是利用并发包提供的线程安全容器类：</p>
<ul>
<li>各种并发容器，比如 ConcurrentHashMap, CopyOnWriteArrayList</li>
<li>各种线程安全队列(Queue, Deque)，如 ArrayBlockingQueue, SynchronousQueue</li>
<li>各种有序容器的线程安全版本等</li>
</ul>
<p>具体实现方式包括从简单的 synchronize 方式，到更加精细化的，比如基于分离锁实现的 ConcurrentHashMap等并发实现等。</p>
<p>早期 ConcurrentHashMap，其实现是基于：</p>
<ul>
<li>分离锁，也就是将内部进行分段（Segment），里面则是 HashEntry 的数组，和 HashMap类似，哈希相同的条目也是以链表形式存放</li>
<li>HashEntry 内部使用 volatile 的 value 字段来保证可见性，也利用了不可变对象的机制以改进利用 Unsafe 提供的底层能力，比如 volatile access，去直接完成部分操作，以最优化性能，毕竟 Unsafe 中的很多操作都是 JVM intrinsic 优化过的</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/xianyuerrr/PicGo/img/Roaming/Typora/typora-user-images/image-20211211185744744.png" alt="image-20211211185744744" style="zoom: 80%;" />
<h3 id="IO">IO</h3>
<p>区分同步或异步（ synchronous / asynchronous）。简单来说，同步是一种可靠的有序运行机制，当我们进行同步操作时，后续的任务是等待当前调用返回，才会进行下一步。而异步则相反，其他任务不需要等待当前调用返回，通常依靠事件、回调等机制来实现仼务间次序关系。</p>
<p>区分阻塞与非阻塞（ blocking/non- blocking）。在进行阻塞操作时，当前线程会处于阻塞状态，无法从事其他任务，只有当条件就绪才能继续，比如 ServerSocket 新连接建立完毕，或数据读取、写入操作完成；而非阻塞则是不管 IO 操作是否结束，直接返回，相应操作在后台继续处理。</p>
<p>IO 不仅仅是对文件的操作，网络编程中，比如 Socket通信，都是典型的 IO 操作目标。</p>
<p>输入流、输出流（ InputStream / OutputStream）是用于读取或写入<strong>字节</strong>的，例如操作图片文件。而 Reader / Writer则是用于操作<strong>字符</strong>，增加了字符编解码等功能，适用于类似从文件中读取或者写入文本信息。本质上计算机操作的都是字节，不管是网络通信还是文件读取， Reader /  Writer 相当于构建了应用逻辑和原始数据之间的桥梁。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xianyuerrr/PicGo/img/Roaming/Typora/typora-user-images/image-20211211192612692.png" alt="image-20211211192612692"></p>
<p><a href="https://tech.meituan.com/2016/11/04/nio.html">NIO,美团技术团队</a></p>
<h3 id="文件拷贝">文件拷贝</h3>
<ul>
<li>基于输入输出流</li>
</ul>
<p>实际上是进行了多次上下文切换，比如应用读取数据时，先在内核态将数据从磁盘读取到内核缓存，再切换到用户态将数据从内核缓存读取到用户缓存。所以，这种方式会带来一定的额外开销，可能会降低 IO 效率。</p>
<img src="https://cdn.jsdelivr.net/gh/xianyuerrr/PicGo/img/Roaming/Typora/typora-user-images/image-20211211214746352.png" alt="image-20211211214746352" style="zoom:50%;" />
<ul>
<li>基于 NIO transferTo</li>
</ul>
<p>会使用到零拷贝技术，数据传输并不需要用户态参与，省去了上下文切换的开销和不必要的内存拷贝，进而可能提高应用拷贝性能。注意， transferTo 不仅仅是可以用在文件拷贝中，与其类似的，例如读取磁盘文件，然后进行 Socket 发送，同样可以享受这种机制带来的性能和扩展性提高。</p>
<img src="https://cdn.jsdelivr.net/gh/xianyuerrr/PicGo/img/Roaming/Typora/typora-user-images/image-20211211215025155.png" style="zoom:50%;" />
<h3 id="接口和抽象类">接口和抽象类</h3>
<ul>
<li>
<p>接口是对行为的抽象，它是抽象方法的集合，利用接口可以达到AP|定义和实现分离的目的。<br>
接口，不能实例化；不能包含任何非常量成员，任何feld都是隐含着 public static fina的意义；<br>
同时，没有非静态方法实现，也就是说要么是抽象方法，要么是静态方法。</p>
</li>
<li>
<p>Java标准类库中，定义了非常多的接口，比如 java.util.List 抽象类是不能实例化的类，用 abstract 关键字修饰 cass，其目的主要是代码重用。<br>
除了不能实例化，形式上和一般的Java类并没有太大区别，可以有一个或者多个抽象方法，也可以没有抽象方法。抽象类大多用于抽取相关Java类<br>
的共用方法实现或者是共同成员变量，然后通过继承的方式达到代码复用的目的。Java标准库中，比如 collection框架，<br>
很多通用部分就被抽取成为抽象类，例如 java util. AbstractList.</p>
</li>
</ul>
<p>相比于其他面向对象语言，Java 在设计上有一些基本区别，比如 Java 不支持多继承。在规范代码的同时，也产生了一些局限性</p>
<h2 id="Java-进阶">Java 进阶</h2>
<h3 id="synchronized-和-ReentrantLock">synchronized 和 ReentrantLock</h3>
<p>线程安全是一个多线程环境下正确性的概念，也就是保证多线程环境下<strong>共享的</strong>、<strong>可修改的</strong>状态的正确性，<br>
这里的状态反映在程序中其实可以看作是数据。</p>
<p>线程安全需要保证几个基本特性：</p>
<ul>
<li>原子性，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。</li>
<li>可见性，是—个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上， volatile就是负责保证可见性的。</li>
<li>有序性，是保证线程内串行语义，避免指令重排等。</li>
</ul>
<p>synchronized 和 ReentrantLock 的性能不能一概而论，早期版本 synchronized 在很多场景下性能相差较大，在后续版本进行了较多改进，<br>
在低竞争场景中表现可能优于 ReentrantLock。</p>
<p>如果使用 synchronized，我们根本无法进行公平性的选择，其永远是不公平的，这也是主流操作系统线程调度的选择。<br>
通用场景中，公平性未必有想象中的那么重要，Java默认的调度策略很少会导致“饥饿”发生。与此同时，若要保证公平性则会引入额外开销，<br>
自然会导致一定的吞吐量下降。所以，我建议只有当你的程序确实有公平性需要的时候，才有必要指定它。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xianyuerrr/PicGo/img/Roaming/Typora/typora-user-images/image-20211214172357844.png" alt="image-20211214172357844"></p>
<p>为什么我们需要读写锁（ReadWriteLock）等其他锁呢？</p>
<p>这是因为，虽然 ReentrantLock 和 synchronized 简单实用，但是行为上有一定局限性，通俗点说就是“太霸道”，要么不占，要么独占。实际应用场景中，有的时候不需要大量竞争的写操作，而是以并发读取为主，如何进一步优化并发操作的粒度呢？</p>
<p>Java 并发包提供的读写锁等扩展了锁的能力，它所基于的原理是<strong>多个读操作是不需要互斥的</strong>，因为读操作并不会更改数据，所以不存在互相干扰。而<strong>写操作则会导致并发一致性的问题</strong>，所以写线程之间、读写线程之间，需要精心设计的互斥逻辑。</p>
<h3 id="synchronized-底层，锁的升降级">synchronized 底层，锁的升降级</h3>
<p>synchronized 代码段是由一对 monitorenter / monitorexit 指令实现，Monitor 对象是同步的基本实现单元。<br>
Monitor 的实现完全依靠操作系统内部的互斥锁，由于需要从用户态切换到内核态，所以同步操作是<strong>无差别的重量级操作</strong>。</p>
<p>JVM 提供了三种不同的 Monitor 实现，也就是三种不同的锁：偏向锁(Biased Locking)、轻量级锁、重量级锁。<br>
当 JVM 检测到不同的竞争状况时，会自动切换到适合的锁实现，这种切换就是锁的升、降级，是 JVM 对synchronized 的优化机制。</p>
<p>当没有竞争出现时，默认会使用偏斜锁。JVM会利用CAS 操作（compare and swap），在对象头上的 Mark Word 部分设置线程ID，<br>
以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。这样做的假设是基于在很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，<br>
使用偏斜锁可以降低无竞争开销。</p>
<p>如果有另外的线程试图锁定某个已经被偏斜过的对象，JVM就需要撤销（revoke）偏斜锁，并切换到轻量级锁实现。<br>
轻量级锁依赖 CAS 操作 Mark Word 来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁。</p>
<p>有的观点认为Java不会进行锁降级。实际上，锁降级确实是会发生的，当 JVM 进入安全点（SafePoint）时，会检查是否有闲置的 Monitor，然后试图进行降级。</p>
<p>自旋锁：竞争锁的失败的线程，并不会真实的在操作系统层面挂起等待，而是JVM会让线程做几个空循环（基于预测在不久的将来就能获得），<br>
在经过若干次循环后，如果可以获得锁，那么进入临界区，如果还不能获得锁，才会真实的将线程在操作系统层面进行挂起。<br>
优点是减少了上下文切换，缺点是消耗 cpu。注意，单 cpu 无效，因为基于 CAS 的轮询会占用 cpu 导致无法进行线程切换</p>
<p><img src="https://cdn.jsdelivr.net/gh/xianyuerrr/PicGo/img/Roaming/Typora/typora-user-images/image-20211214171903307.png" alt="image-20211214171903307"></p>
<h3 id="一个线程两次调用-start-方法">一个线程两次调用 start() 方法</h3>
<p>从操作系统的角度看，线程是系统调度的最小单元，一个进程可以包含多个线程，作为任务的真正运作者，<br>
有自己的栈（Stack）、寄存器（Register）、本地存储（Thread Local）等，但是会和进程内其他线程共享文件描述符、虚拟地址空间等。</p>
<p>在具体实现中，线程还分为内核线程、用户线程，Java 的线程实现与虚拟机相关。对于我们最熟悉的 Sun/OracleJDK，<br>
其线程也经历了一个演进过程，基本上在 Java 1.2之后，JDK 已经抛弃了所谓的 Green Thread，也就是用户调度的线程，<br>
现在的模型是 <strong>一对一映射到操作系统内核线程</strong>。</p>
<p>Java 的线程是不允许启动两次的，第二次调用必然会抛出 IllegalThreadStateException，这是一种运行时异常，多次调用 start 被认为是编程错误。</p>
<p><a href="./src/juc/juc.md">Java 线程</a></p>
<p>在第二次调用 start() 方法时，线程可能处于终止或者其他（非 NEW 状态），但是不论如何，都是不能再次启动的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xianyuerrr/PicGo/img/Roaming/Typora/typora-user-images/image-20211214190654990.png" alt="image-20211214190654990"></p>
<h3 id="死锁的产生、定位、修复">死锁的产生、定位、修复</h3>
<p><img src="https://cdn.jsdelivr.net/gh/xianyuerrr/PicGo/img/Roaming/Typora/typora-user-images/image-20211214195224437.png" alt="dl"></p>
<ul>
<li>
<p>首先，可以使用 jps 或者系统的 ps 命令、任务管理器等工具，确定进程 ID。</p>
</li>
<li>
<p>其次，调用 jstack 获取线程栈</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">jstack your_pid<br></code></pre></td></tr></table></figure>
<ul>
<li>
<p>分析得到的输出，如图：<br>
<img src="https://cdn.jsdelivr.net/gh/xianyuerrr/PicGo/img/Roaming/Typora/typora-user-images/image-20211214195559631.png" alt="image-20211214195559631"></p>
</li>
<li>
<p>最后结合代码分析线程栈信息</p>
</li>
</ul>
<p>总体上可以理解为：<br>
区分线程状态 -&gt; 查看等待目标 -&gt; 对比 Monitor 等持有状态</p>
<h3 id="Java-并发包工具类">Java 并发包工具类</h3>
<p>java.util.concurrent 及其子包：</p>
<ol>
<li>
<p>比 synchronized 更加高级的各种同步结构，包括 CountDownLatch、CyclicBarrier、Semaphore 等，可以实现更加丰富的多线程操作，<br>
比如利用 Semaphore 作为资源控制器，限制同时进行工作的线程数量。</p>
</li>
<li>
<p>各种线程安全的容器，比如最常见的 ConcurrentHashMap、有序的 ConcunrrentSkipListMap，或者通过类似快照机制，<br>
实现线程安全的动态数组 CopyOnWriteArrayList 等。</p>
</li>
<li>
<p>各种并发队列实现，如各种 BlockedQueue 实现，比较典型的 ArrayBlockingQueue、SynchorousQueue<br>
或针对特定场景的 PriorityBlockingQueue 等。</p>
</li>
<li>
<p>强大的 Executor 框架，可以创建各种不同类型的线程池，调度任务运行等，绝大部分情况下，不再需要自己从头实现线程池和任务调度器。</p>
</li>
</ol>
<ul>
<li>CountDownLatch, 允许一个或多个线程等待某些操作完成。</li>
<li>CyclicBarrier, 一种辅助性的同步结构，允许多个线程等待到达某个屏障。</li>
<li>Semaphore, Java 版本的信号量实现。</li>
</ul>
<h3 id="ConcurrentLinkedQueue-和-LinkedBlockingQueue">ConcurrentLinkedQueue 和 LinkedBlockingQueue</h3>
<p>严格来讲，类似 ConcurrentLinkedQueue 这种 “Concurrent” 容器，才真正代表并发。</p>
<p>区别：</p>
<ul>
<li>Concurrent 类型基于 lock-free，在常见的多线程访问场景，一般可以提供较高吞吐量。</li>
<li>LinkedBlockingQueue 基于锁，并提供了 BlockingQueue 的等待性方法。</li>
</ul>
<p>java.util.concurrent 包提供的容器（Queue、List、Set、Map），从命名上可以大概区分为 Concurrent、CopyOnWrite 和 Blocking 三类，<br>
同样是线程安全容器，可以简单认为：</p>
<ul>
<li>Concurrent 类型没有 CopyOnWrite 类容器相对较重的修改开销。但是，Concurrent 往往提供了较低的遍历一致性。</li>
</ul>
<p>弱一致性，可以理解为，当利用迭代器遍历时，即便容器发生修改，迭代器仍然可以继续进行遍历。<br>
弱一致性的另外一个体现是，size 等操作准确性是有限的，未必是100%准确。与此同时，读取的性能具有一定的不确定性。</p>
<p>与弱一致性对应的，就是我介绍过的同步容器常见的行为 “fail-fast&quot;，也就是如果检测到容器在遍历过程中发生了修改，<br>
则抛出 ConcurrentModificationException，不再继续遍历。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xianyuerrr/PicGo/img/Roaming/Typora/typora-user-images/image-20211214235207018.png" alt="image-20211214235207018"></p>
<h3 id="线程池">线程池</h3>
<p>Executors 目前提供了 5 种不同的线程池创建配置：</p>
<ul>
<li>
<p>newCachedThreadPool()，它是一种用来处理<strong>大量短时间工作任务</strong>的线程池。<br>
具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；<br>
如果线程闲置的时间超过60秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列。</p>
</li>
<li>
<p>newFixedThreadPool(int nThreads)，重用指定数目 (nThreads) 的线程，其背后使用的是无界的工作队列，<br>
任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；<br>
如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads。</p>
</li>
<li>
<p>newSingleThreadExecutor()，它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被<strong>顺序执行</strong>，<br>
最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目。</p>
</li>
<li>
<p>newSingleThreadScheduledExecutor() 和 newScheduledThreadPool(int corePoolSize)，创建的是个 ScheduledExecutorService，<br>
可以进行<strong>定时或周期性的工作调度</strong>，区别在于单一工作线程还是多个工作线程。</p>
</li>
<li>
<p>newWorkStealingPool(int parallelism)，这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建 ForkJoinPool，<br>
利用 Work-Stealing 算法，并行地处理任务，不保证处理顺序。</p>
</li>
</ul>
<p>线程池这个定义就是个容易让人误解的术语，因为 ExecutorService 除了通常意义上“池”的功能，还提供了更全面的<strong>线程管理</strong>、<strong>任务提交</strong>等方法。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xianyuerrr/PicGo/img/Roaming/Typora/typora-user-images/image-20211215192855321.png" alt="image-20211215192855321"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xianyuerrr/PicGo/img/Roaming/Typora/typora-user-images/image-20211215193022863.png" alt="image-20211215193022863"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xianyuerrr/PicGo/img/Roaming/Typora/typora-user-images/image-20211215195104453.png" alt="image-20211215195104453"></p>
<h3 id="AtomicInteger">AtomicInteger</h3>
<p>AtomicIntger 是对 int 类型的一个封装，提供原子性的访问和更新操作，其原子性操作的实现是基于 CAS（compare-and-swap）技术。在大部分<br>
处理器上 CAS 都是一个非常轻量级的操作。</p>
<p>CAS 也并不是没有副作用，试想，其常用的失败重试机制，隐含着一个假设，即竞争情况是短暂的。大多数应用场景中，<br>
确实大部分重试只会发生一次就获得了成功，但是总是有意外情况，所以在有需要的时候，还是要考虑限制自旋的次数，以免过度消耗 CPU。</p>
<p>另外一个就是著名的 ABA 问题，这是通常只在 lock-free 算法下暴露的问题。我前面说过 CAS 是在更新时比较前值，如果对方只是恰好相同，<br>
例如期间发生了 A-&gt;B-&gt;A 的更新，仅仅判断数值是 A，可能导致不合理的修改操作。针对这种情况，Java 提供了 AtomicStampedReference 工具类，<br>
通过为引用建立类似版本号（stamp）的方式，来保证 CAS 的正确性。</p>
<p>AbstractQueuedSynchronizer(AQS)内部数据和方法可以简单拆分为：</p>
<ul>
<li>一个 volatile 的整数成员表征状态，同时提供了 setState 和 getState 方法</li>
<li>一个先入先出（FIFO）的等待线程队列，以实现多线程间竞争和等待，这是 AQS 机制的核心之一。</li>
<li>各种基于 CAS 的基础操作方法，以及各种期望具体同步结构去实现的 acquire/release 方法。</li>
</ul>
<p>利用 AQS 实现一个同步结构，至少要实现两个基本类型的方法，分别是 acquire 操作，获取资源的独占权；还有就是 release 操作，释放对某个资源的独占。</p>
<h3 id="类加载过程，双亲委派模型">类加载过程，双亲委派模型</h3>
<p>一般来说，我们把 Java 的类加载过程分为三个主要步骤：加载、链接、初始化。</p>
<p>首先是加载阶段（Loading），它是 Java 将字节码数据从不同的数据源读取到 JVM 中，并映射为JVM 认可的数据结构（Class对象），<br>
这里的数据源可能是各种各样的形态，如 jar 文件、class 文件，甚至是网络数据源等；如果输入数据不是 ClassFile 的结构，<br>
则会抛出 ClassFormatError。</p>
<p>第二阶段是链接（Linking），这是核心的步骤，简单说是把原始的类定义信息平滑地转化入 JVM 运行的过程中。这里可进一步细分为三个步骤：</p>
<ul>
<li>
<p>验证（Verification），这是虚拟机安全的重要保障，JVM 需要核验字节信息是符合 Java 虚拟机规范，否则就被认为是 VerifyError，<br>
这样就防止了恶意信息或者不合规的信息危害 JVM 的运行，验证阶段有可能触发更多 class 的加载。</p>
</li>
<li>
<p>准备（Preparation），创建类或接口中的静态变量，并初始化静态变量的初始值。但这里的“初始化”和下面的显式初始化阶段是有区别的，<br>
侧重点在于分配所需要的内存空间，不会去执行更进一步的 JVM 指令。</p>
</li>
<li>
<p>解析（Resolution），在这一步会将常量池中的符号引用（symbolic reference）替换为直接引用。</p>
</li>
</ul>
<p>最后是初始化阶段（initialization），这一步真正去执行类初始化的代码逻辑，包括静态字段赋值的动作，<br>
以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，父类型的初始化逻辑优先于当前类型的逻辑。</p>
<p>双亲委派模型，简单说就是当类加载器（Class-Loader）试图加载某个类型的时候，除非父加载器找不到相应类型，<br>
否则尽量将这个任务代理给当前加载器的父加载器去做。使用委派模型的目的是避免重复加载 Java 类型。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xianyuerrr/PicGo/img/Roaming/Typora/typora-user-images/image-20211216234812598.png" alt="image-20211216234812598"></p>
<p>通常类加载机制有三个基本特征：</p>
<ul>
<li>
<p>双亲委派模型。但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，<br>
比如 JDK 内部的 ServiceProvider/ServiceLoader 机制，用户可以在标准 API 框架上，提供自己的实现，JDK 也需要提供些默认的参考实现。<br>
例如，Java 中 JNDI、JDBC、文件系统、Cipher 等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。</p>
</li>
<li>
<p>可见性，子类加载器可以访问父加载器加载的类型，但是反过来是不允许的，不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑。</p>
</li>
<li>
<p>单一性，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。<br>
但是注意，类加载器“邻居”间，同一类型仍然可以被加载。</p>
</li>
</ul>
<h3 id="运行时动态生成类">运行时动态生成类</h3>
<p>通常的开发过程是，开发者编写 Java 代码，调用 javac 编译成 class 文件，然后通过类加载机制载入 JVM，就成为应用运行时可以使用的 Java 类了。</p>
<p>有一种笨办法，直接用 ProcessBuilder 之类启动 javac 进程，并指定上面生成的文件作为输入，进行编译。<br>
最后，再利用类加载器，在运行时加载即可。这种方法本质上还是在当前程序之外编译的。</p>
<p>可以使用 Java Compiler APl，这是 JDK 提供的标准 API，里面提供了与 javac 对等的编译器功能，具体请参考 java.compiler 相关文档。</p>
<p>进一步思考，我们一直围绕 Java 源码编译成为 JVM 可以理解的字节码，换句话说，只要是符合 JVM 规范的字节码，不管它是如何生成的，<br>
是不是都可以被JVM加载呢？我们能不能直接生成相应的字节码，然后交给类加载器去加载呢？当然也可以，不过直接去写字节码难度太大，<br>
通常我们可以利用 Java 字节码操纵工具和类库来实现，比如在专栏第 6 讲中提到的 ASM、Javassist、cglib等。</p>
<p>对于一个普通的 Java 动态代理，其实现过程可以简化成为：</p>
<ul>
<li>提供一个基础的接口，作为被调用类型（com.mycorp.Hellolmpl）和代理类之间的统一入口，如 com.mycorp.Hello。</li>
<li>实现 invocationHandler，对代理对象方法的调用，会被分派到其 invoke 方法来真正实现动作。</li>
<li>通过 Proxy 类，调用其 newProxylnstance 方法，生成一个实现了相应基础接口的代理类实例。动态代码就是在这个时候生成的。</li>
</ul>
<h3 id="JVM-内存区域的划分，哪些区域可能发生-OOM">JVM 内存区域的划分，哪些区域可能发生 OOM</h3>
<ul>
<li>
<p>程序计数器（PC，Program Counter Register）。在JVM规范中，每个线程都有它自己的程序计数器，并且任何时间一个线程都只有一个方法在执行，<br>
也就是所谓的当前方法。程序计数器会存储当前线程正在执行的 Java 方法的 JVM 指令地址；或者，如果是在执行本地方法，则是未指定值（undefined）。</p>
</li>
<li>
<p>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的<br>
栈帧（Stack Frame），对应着一次次的Java 方法调用。<br>
前面谈程序计数器时，提到了当前方法；同理，在一个时间点，对应的只会有一个活动的栈帧，<br>
通常叫作当前帧，方法所在的类叫作当前类。如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，成为新的当前帧，<br>
一直到它返回结果或者执行结束。JVM 直接对 Java 栈的操作只有两个，就是对栈帧的压栈和出栈。<br>
栈帧中存储着局部变量表、操作数（operand）栈、动态链接、方法正常退出或者异常退出的定义等。</p>
</li>
<li>
<p>堆（Heap），它是 Java 内存管理的核心区域，用来放置 Java 对象实例，几乎所有创建的 Java 对象实例都是被直接分配在堆上。<br>
堆被所有的线程共享，在虚拟机启动时，我们指定的 “Xmx” 之类参数就是用来指定最大堆空间等指标。</p>
</li>
</ul>
<p>理所当然，堆也是垃圾收集器重点照顾的区域，所以堆内空间还会被不同的垃圾收集器进行进一步的细分，最有名的就是新生代、老年代的划分。</p>
<ul>
<li>方法区（Method Area）。这也是所有线程共享的一块内存区域，用于存储所谓的元（Meta）数据，例如类结构信息，<br>
以及对应的运行时常量池、字段、方法代码等。</li>
</ul>
<p>由于早期的 Hotspot JVM 实现，很多人习惯于将方法区称为永久代（Permanent Generation）。Oracle JDK 8中将永久代移除，<br>
同时增加了元数据区（Metaspace）。</p>
<ul>
<li>
<p>运行时常量池（Run-Time Constant Pool），这是方法区的一部分。如果仔细分析过反编译的类文件结构，<br>
你能看到版本号、字段、方法、超类、接口等各种信息，还有一项信息就是常量池。Java 的常量池可以存放各种常量信息，<br>
不管是编译期生成的各种字面量，还是需要在运行时决定的符号引用，所以它比一般语言的符号表存储的信息更加宽泛。</p>
</li>
<li>
<p>本地方法栈（Native Method Stack）。它和 Java 虚拟机栈是非常相似的，支持对本地方法的调用，也是每个线程都会创建一个。<br>
在 Oracle Hotspot JVM 中，本地方法栈和 Java 虚拟机栈是在同一块儿区域，这完全取决于技术实现的决定，并未在规范中强制。</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/xianyuerrr/PicGo/img/Roaming/Typora/typora-user-images/image-20211223200544777.png" alt="image-20211223200544777" style="zoom: 67%;" />
<ul>
<li>
<p>直接内存（Direct Memory）区域，它就是 Direct Buffer 所直接分配的内存，也是个容易出现问题的地方。尽管，在 JVM 工程师的眼中，<br>
并不认为它是 JVM 内部内存的一部分，也并未体现在 JVM 内存模型中。</p>
</li>
<li>
<p>JVM 本身是个本地程序，还需要其他的内存去完成各种基本任务，比如，JIT Compiler 在运行时对热点方法进行编译，<br>
就会将编译后的方法储存在 Code Cache 里面；GC 等功能需要运行在本地线程之中，类似部分都需要占用内存空间。这些是实现 JVM JIT 等功能的需要，<br>
但规范中并不涉及。</p>
</li>
</ul>
<p>OOM 通俗点儿说，就是 JVM 内存不够用了，javadoc 中对 OutOfMemoryError 的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。<br>
在抛出 OOM 之前，通常垃圾收集器会被触发，尽可能去清理空间。当然，也不是在任何情况下垃圾收集器都会被触发。比如，我们去分配一个超大对象，<br>
类似一个超大数组超过堆的最大值，JVM 可以判断出垃圾收集并不能解决这个问题，所以直接抛出 OutOfMemoryError。</p>
<p>除了程序计数器，其它区域可能因为空间不足而发生 OOM。</p>
<h3 id="诊断和监控-JVM-堆内和堆外内存的使用">诊断和监控 JVM 堆内和堆外内存的使用</h3>
<p>有点脱轨，暂时没必要看这一章</p>
<h3 id="Java-常见的垃圾收集器">Java 常见的垃圾收集器</h3>
<p>GC(Garbage Collector)是和具体 JVM 实现紧密相关的，不同厂商（IBM、Oracle）、不同版本的 JVM，提供的选择不同。以下为最主流的 Oracle JDK。</p>
<ul>
<li>
<p>Serial GC，是最古老的垃圾收集器，“Serial&quot;体现在其收集工作是<strong>单线程</strong>的，并且在进行垃圾收集过程中，会进入臭名昭著的“<strong>Stop-The-World</strong>&quot;状态。<br>
当然，其单线程设计也意味着精简的GC实现，无需维护复杂的数据结构，初始化也简单，所以一直是 <strong>Client 模式下 JVM 的默认选项</strong>。<br>
通常将其老年代实现单独称作 Serial Old，它采用了==标记-整理==（Mark-Compact）算法，区别于新生代的==复制==算法。</p>
</li>
<li>
<p>ParNew GC，是个新生代 GC 实现，实际是 Serial GC 的多线程版本，最常见的应用场景是配合老年代的 CMS GC工作.</p>
</li>
<li>
<p>CMS（Concurrent Mark Sweep）GC，基于==标记-清除==（Mark-Sweep）算法，设计目标是<strong>尽量减少停顿时间</strong>，<br>
这一点对于 Web 等反应时间敏感的应用非常重要，一直到今天，仍然有很多系统使用 CMS GC。但是，CMS 采用的标记-清除算法，<br>
存在着<strong>内存碎片化</strong>问题，所以难以避免在长时间运行等情况下发生 fullGC，导致恶劣的停顿。另外，既然强调了并发（Concurrent），<br>
CMS会占用更多<strong>CPU</strong>资源，并和用户线程争抢。</p>
</li>
<li>
<p>Parrallel GC，在早期 JDK8 等版本中，它是 <strong>server 模式 JVM 的默认选择</strong>，也被称作是<strong>吞吐量优先</strong>的 GC。<br>
它的算法和 Serial GC 比较相似，尽管实现要复杂的多，其特点是新生代和老年代 GC 都是<strong>并行</strong>进行的，在常见的服务器环境中更加高效。</p>
</li>
<li>
<p>G1 GC，这是一种<strong>兼顾吞吐量和停顿时间</strong>的 GC 实现，是 Oracle <strong>JDK9 以后的默认选项</strong>。G1 可以直观的设定停顿时间的目标，相比于 CMSGC，<br>
G1未必能做到 CMS 在最好情况下的延时停顿，但是<strong>最差情况要好很多</strong>。<br>
G1 GC 仍然存在着年代的概念，但是其内存结构并不是简单的条带式划分，而是类似棋盘的一个个 region。Region 之间是==复制==算法，<br>
但整体上实际可看作是==标记-整理==（Mark-Compact）算法，可以有效地避免内存碎片，尤其是当 Java 堆非常大的时候，G1 的优势更加明显。<br>
G1 吞吐量和停顿表现都非常不错，并且仍然在不断地完善，与此同时 CMS 已经在 JDK9 中被标记为废弃（deprecated），所以 G1 GC 值得你深入掌握。</p>
</li>
</ul>
<p>自动垃圾收集的前提是清楚哪些内存可以被释放。主要是两个方面，最主要部分就是 <strong>对象</strong> 实例，都是存储在堆上的；<br>
还有就是方法区中的 <strong>元数据</strong> 等信息，例如类型不再使用，卸载该 Java 类似乎是很合理的。</p>
<p>对于对象实例收集，主要是两种基本算法，<strong>引用计数</strong> （Python）和 <strong>可达性分析</strong> （Java）。</p>
<p>方法区无用元数据的回收比较复杂，还记得我对类加载器的分类吧，一般来说初始化类加载器加载的类型是<strong>不会进行类卸载</strong>（unload）的；<br>
而普通的类型的卸载，往往是要求<strong>相应自定义类加载器本身被回收</strong>，所以大量使用动态类型的场合，需要防止元数据区（或者早期的永久代）不会OOM。</p>
<p>常见的垃圾收集算法，其主要分为三类：</p>
<ul>
<li>
<p>复制（Copying）算法，我前面讲到的新生代 GC，基本都是基于复制算法，将活着的对象复制到 to 区域，<br>
拷贝过程中将对象顺序放置，就可以避免内存碎片化。这么做的代价是，既然要进行复制，既要提前预留内存空间，有一定的浪费；<br>
另外，对于 G1 这种分拆成为大量 region 的 GC，复制而不是移动，意味着 GC 需要维护 region 之间对象引用关系(为啥移动就不需要了？？？)，<br>
这个开销也不小，不管是内存占用或者时间开销。</p>
</li>
<li>
<p>标记-清除（Mark-Sweep）算法，首先进行标记工作，标识出所有要回收的对象，然后进行清除。这么做除了标记、清除过程效率有限，<br>
另外就是不可避免的出现碎片化问题，这就导致其不适合特别大的堆；否则，一旦出现 FullGC，暂停时间可能根本无法接受。</p>
</li>
<li>
<p>标记-整理（Mark-Compact），类似于标记-清除，但为避免内存碎片化，它会在清理过程中将对象移动，以确保移动后的对象占用连续的内存空间。</p>
</li>
</ul>
<p>垃圾收集过程的理解：</p>
<ul>
<li>
<p>Java 应用不断创建对象，通常都是分配在 Eden 区域，当其空间占用达到一定阈值时，触发 Minor GC。仍然被引用的对象存活下来，<br>
被复制到 JVM 选择的 Survivor 区域，而没有被引用的对象则被回收。</p>
</li>
<li>
<p>经过一次 Minor GC，Eden 就会空闲下来，直到再次达到 Minor GC 触发条件，这时候，另外一个 Survivor 区域则会成为 to 区域，<br>
Eden 区域的存活对象和 From 区域对象，都会被复制到 to 区域，并且存活的年龄计数会被加1。</p>
</li>
<li>
<p>类似第二步的过程会发生很多次，直到有对象年龄计数达到阈值，这时候就会发生所谓的晋升（Promotion）过程，超过阈值的对象会被晋升到老年代。</p>
</li>
</ul>
<p>后面就是老年代 GC，具体取决于选择的 GC 选项，对应不同的算法。</p>
<h3 id="GC-调优">GC 调优</h3>
<p>从性能的角度看，通常关注三个方面，内存占用（footprint）、延时（latency）和吞吐量（throughput），<br>
大多数情况下调优会侧重于其中一个或者两个方面的目标，很少有情况可以兼顾三个不同的角度。当然，除了上面通常的三个方面，<br>
也可能需要考虑其他 GC 相关的场景，例如，OOM 也可能与不合理的 GC 相关参数有关；或者，应用启动速度方面的需求，GC 也会是个考虑的方面。</p>
<p>详细内容暂时没必要看</p>
<h3 id="happen-before">happen-before</h3>
<p>Happen-before 关系，是 Java 内存模型中保证多线程操作可见性的机制，也是对早期语言规范中含糊的<strong>可见性</strong>概念的一个精确定义。</p>
<p>它的具体表现形式，包括但远不止是我们直觉中的 synchronized、volatile、lock 操作顺序等方面，例如：</p>
<ul>
<li>线程内执行的每个操作，都保证 happen-before 后面的操作，这就保证了基本的程序顺序规则，这是开发者在书写程序时的基本约定。</li>
<li>对于 volatile 变量，对它的写操作，保证 happen-before 在随后对该变量的读取操作。</li>
<li>对于一个锁的解锁操作，保证 happen-before 加锁操作。</li>
<li>对象构建完成，保证 happen-before 于 finalizer 的开始动作。</li>
<li>甚至是类似线程内部操作的完成，保证 happen-before 其他Thread.join() 的线程等。</li>
</ul>
<p>这些 happen-before 关系是存在着传递性的，如果满足 a happen-before b 和 b happen-before c，那么a happen-before c 也成立。</p>
<p>happen-before 不仅是对执行时间顺序的保证，包括对内存读写顺序的保证。如果仅仅是时钟顺序的先后，并不能保证线程交互的可见性。</p>
<p>JMM 内部的实现通常是依赖于所谓的内存屏障，通过禁止某些重排序的方式，提供内存可见性保证，也就是实现了各种 happen-before 规则。<br>
与此同时，更多复杂度在于，需要尽量确保各种编译器、各种体系结构的处理器，都能够提供一致的行为。</p>
<p>对于一个volatile变量：</p>
<ul>
<li>对该变量的写操作之后，编译器会插入一个写屏障。</li>
<li>对该变量的读操作之前，编译器会插入一个读屏障。</li>
</ul>
<h3 id="Java-程序运行在-Docker等容器环境有哪些新问题">Java 程序运行在 Docker等容器环境有哪些新问题</h3>
<p>对于 Java 来说，Docker 毕竟是一个较新的环境，例如，其内存、CPU 等资源限制是通过 CGroup（Control Group）实现的，<br>
早期的 JDK 版本（8u131之前）并不能识别这些限制，进而会导致一些基础问题：</p>
<ul>
<li>
<p>如果未配置合适的 JVM 堆和元数据区、直接内存等参数，Java 就有可能试图使用超过容器限制的内存，最终被容器 OOM kill，或者自身发生OOM。</p>
</li>
<li>
<p>错误判断了可获取的 CPU 资源，例如，Docker 限制了 CPU 的核数，JVM 就可能设置不合适的 GC 并行线程数等。</p>
</li>
</ul>
<p>从应用打包、发布等角度出发，JDK 自身就比较大，生成的镜像就更为臃肿，当我们的镜像非常多的时候，镜像的存储等开销就比较明显了。</p>
<p>如果考虑到微服务、Serverless 等新的架构和场景，Java 自身的大小、内存占用、启动速度，都存在一定局限性，<br>
因为 Java 早期的优化大多是针对长时间运行的大型服务器端应用。</p>
<p><strong>Docker 有什么特别</strong></p>
<p>虽然看起来 Docker 之类容器和虚拟机非常相似，例如，它也有自己的 shell，能独立安装软件包，运行时与其他容器互不干扰。<br>
但是，如果深入分析你会发现，Docker 并不是一种完全的虚拟化技术，而更是一种轻量级的隔离技术。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xianyuerrr/PicGo/img/Roaming/Typora/typora-user-images/image-20211223212206102.png" alt="image-20211223212206102"></p>
<p>从技术角度，基于 namespace，Docker 为每个容器提供了单独的命名空间，对网络、PID、用户、IPC通信、文件系统挂载点等实现了隔离。<br>
对于 CPU、内存、磁盘IO 等计算资源，则是通过 CGroup 进行管理。</p>
<p>Docker 仅在类似 Linux 内核之上实现了有限的隔离和虚拟化，并不是像传统虚拟化软件那样，独立运行一个新的操作系统。如果是虚拟化的操作系统，<br>
不管是 Java 还是其他程序，只要调用的是同一个系统 API，都可以透明地获取所需的信息，基本不需要额外的兼容性改变。</p>
<p>对于 Java 平台来说，这些未隐藏的底层信息带来了很多意外的困难，主要体现在几个方面：</p>
<ul>
<li>
<p>容器环境对于计算资源的管理方式是全新的，CGroup 作为相对比较新的技术，历史版本的 Java 显然并不能自然地理解相应的资源限制。</p>
</li>
<li>
<p>namespace 对于容器内的应用细节增加了一些微妙的差异，比如 jcmd、jstack 等工具会依赖于&quot;/proc//”下面提供的部分信息，<br>
但是 Docker 的设计改变了这部分信息的原有结构，我们需要对原有工具进行修改以适应这种变化。</p>
</li>
</ul>
<h3 id="注入攻击">注入攻击</h3>
<p>注入式（Inject）攻击是一类非常常见的攻击方式，其基本特征是程序允许攻击者将不可信的动态内容注入到程序中，并将其执行，<br>
这就可能完全改变最初预计的执行过程，产生恶意效果。</p>
<p>下面是几种主要的注入式攻击途径，原则上提供<strong>动态执行能力</strong>的语言特性，都需要提防发生注入攻击的可能。</p>
<ul>
<li>SQL 注入攻击</li>
<li>操作系统命令注入攻击</li>
<li>XML 注入攻击</li>
</ul>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Jupyter 设置中英文</title>
    <url>/2021/01/29/Jupyter-%E8%AE%BE%E7%BD%AE%E4%B8%AD%E8%8B%B1%E6%96%87/</url>
    <content><![CDATA[<p>jupyter设置中/英文语言</p>
<p>设置成英文：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">set LC_ALL=en_US.UTF-8<br></code></pre></td></tr></table></figure>
<p>设置成中文：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">set LC_ALL=zh_CN.UTF-8<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Jupyter</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 命令</title>
    <url>/2021/01/30/Linux-%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>@TOP[Linux学习]</p>
<h1>新手必须掌握的命令</h1>
<h2 id="常用系统工作命令">常用系统工作命令</h2>
<p>1、echo #提取值并且输出字符</p>
<p>2、date #查看系统当前时间</p>
<p>4、poweroff #关机</p>
<p>5、wget #下载文件</p>
<p>6、ps #查看进程</p>
<p>7、top #监视进程活动与系统负载</p>
<p>8、pidof #查询进程的PID</p>
<p>9、killall #终止服务的所有进程</p>
<h2 id="系统状态检测命令">系统状态检测命令</h2>
<p>1、ifconfig #获取网卡配置</p>
<p>2、uname #查看内核和系统版本</p>
<p>3、uptime #查看系统负载</p>
<p>4、free #查看内存使用信息</p>
<p>5、who #查看登陆的用户信息</p>
<p>6、last #查看所有系统登陆记录</p>
<p>7、history #查看历史命令</p>
<h2 id="工作目录切换命令">工作目录切换命令</h2>
<p>1、pwd #显示当前工作目录</p>
<p>2、cd #切换工作路径</p>
<p>3、ls #显示目录中的文件信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">ls -a #查看包括隐藏文件的全部文件<br>ls-l #查看文件的详细信息<br></code></pre></td></tr></table></figure>
<h2 id="文本编辑命令">文本编辑命令</h2>
<p>1、cat #查看纯文本文件（内容较少的）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br></code></pre></td></tr></table></figure>
<p>2、more #查看纯文本文件（内容较多的）</p>
<p>3、head #查看文本的前n行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">head -n 数字 文件名<br></code></pre></td></tr></table></figure>
<p>4、tail #查看文本的后n行（可以持续刷新）</p>
<p>5、tr #替换文本文件中的字符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">cat 文件名 | tr [原始字符] [新字符]<br></code></pre></td></tr></table></figure>
<p>6、wc #统计指定文本的行数、字数、字节数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">wc[参数] 文件名<br>可选参数：<br>4-l 只显示行数<br>4-w只显示单词数<br>4-c只显示字节数<br></code></pre></td></tr></table></figure>
<p>7、stat #查看文件的具体存储信息和时间信息等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">stat 文件名<br></code></pre></td></tr></table></figure>
<p>8、cut #按列提取文本字符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">cut[参数] 文本<br>可选参数：<br>4-d 分隔符<br>4-f 查看的列数<br></code></pre></td></tr></table></figure>
<p>9、diff 比较文本的差异</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">diff[参数] 文件名1 文件名2<br>可选参数：<br>4-brief 判断文件是否相同<br>4-c 描述文件内容具体的不同<br></code></pre></td></tr></table></figure>
<h2 id="文件目录管理命令">文件目录管理命令</h2>
<p>1、touch #创建空白文件；设置文件的时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">touch[参数][文件]<br>可选参数：<br>4-a 仅修改“读取时间”（atime）<br>4-m 仅修改“修改时间”（mtime）<br>4-d 同时修改atime和mtime<br></code></pre></td></tr></table></figure>
<p>2、mkdir #新建目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">mkdir 目录名<br>mkdir -p a/b/c/d/e 创建具有嵌套关系的目录<br></code></pre></td></tr></table></figure>
<p>3、cp #拷贝文件或目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">cp [参数] 源文件 目的文件<br>可选参数：<br>4-p 保留源文件属性<br>4-d 如果源文件为链接文件，则保留链接文件的属性<br>4-r 递归持续拷贝（目录）<br>4-i 如果目标文件以存在，则询问<br>4-a 相当于-pdf<br></code></pre></td></tr></table></figure>
<p>4、mv #剪切文件或重命名文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">mv[参数] 源文件 [目标路径 | 文件名]<br></code></pre></td></tr></table></figure>
<p>5、rm #删除文件或目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">rm[参数] 文件 （默认只能删除文件）<br>可选参数：<br>4-f 强制删除<br>4-m 用于删除目录<br></code></pre></td></tr></table></figure>
<p>6、dd #按照指定大小和个数的数据块来复制或者转换文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">dd[参数]<br>可选参数：<br>4if 输入的文件名称<br>4of 输出的文件名称<br>4bs 设置每个块的大小<br>4count 设置要复制的块的个数<br>4<br>dd if=xianyue.txt of=xy.txt bs=520M count=1 <br></code></pre></td></tr></table></figure>
<p>7、file 查看文件的类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">file 文件名<br></code></pre></td></tr></table></figure>
<h2 id="打包压缩与搜索命令">打包压缩与搜索命令</h2>
<p>1、tar</p>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux实战</title>
    <url>/2024/01/21/Linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1>Linux 软件安装</h1>
<h2 id="软件包管理器">软件包管理器</h2>
<p>包管理器是方便软件安装、卸载，解决软件依赖关系的重要工具。</p>
<ul>
<li>CentOS、RedHat使用yum包管理器，软件安装包格式为rpm</li>
<li>Debian、Ubuntu使用apt包管理器，软件安装包格式为deb</li>
</ul>
<h2 id="rpm">rpm</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">rpm [-] soft<br>-q 查询软件包<br>-i 安装软件包<br>-e 卸载软件包<br>-a 所有软件包<br></code></pre></td></tr></table></figure>
<p>rpm包的问题：</p>
<ul>
<li>需要自己解决依赖问题</li>
<li>软件来源不可靠</li>
</ul>
<h2 id="yum">yum</h2>
<p>yum源：</p>
<ul>
<li>Centos yum源：<a href="http://mirror.centos.org/centos/7/">http://mirror.centos.org/centos/7/</a></li>
<li>国内镜像：<a href="https://opsx.alibaba.com/mirror">https://opsx.alibaba.com/mirror</a></li>
</ul>
<p>yum配置文件：</p>
<ul>
<li>/etc/yum.repos.d/CentOS-Base.repo</li>
<li>wget -O /etc/yum.repos.d/CentOS-Base.repo <a href="http://mirrors.aliyun.com/repo/Centos-7.repo">http://mirrors.aliyun.com/repo/Centos-7.repo</a></li>
<li>yum makecache</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">yum install soft 安装软件<br>yum remove soft 卸载软件<br>yum list soft 查看软件<br>yum update soft 升级软件<br></code></pre></td></tr></table></figure>
<h2 id="源代码安装">源代码安装</h2>
<ol>
<li><code>wget url</code>，下载二进制包</li>
<li><code>tar -zxf soft.tar.gz</code>，解压二进制包</li>
<li><code>cd soft</code>，进入软件包目录</li>
<li><code>cat README</code>，查看软件 README</li>
<li><code>./configure --prefix=/usr/local/soft</code>，配置程序安装位置</li>
<li><code>make -j2</code>，编译，-j2 表示使用两个逻辑 cpu 进行编译，一定程度上加快编译速度</li>
<li><code>make install</code>，安装软件</li>
</ol>
<h2 id="内核升级">内核升级</h2>
<p>yum安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">uname -r 查看内核版本<br>yum install kernel 安装内核<br></code></pre></td></tr></table></figure>
<p>源代码编译：</p>
<ul>
<li><code>yum install gcc gcc-c++ make ncurses-devel openssl-devel elfutils-libelf-devel</code>，安装依赖包</li>
<li><code>wegt -O kernel.xz https://www.kernel.org</code>，下载内核</li>
<li><code>tar xvf kernel.xz -C /usr/src/kernels</code>，解压内核</li>
<li><code>cd/usr/src/kernels/linux-5.1.10/ &amp;&amp; make menuconfig | allyesconfig | allnoconfig</code>，配置内核编译参数</li>
<li><code>cp /boot/config-kernelversion.platform /usr/src/kernels/linux-5.1.10/.config</code>，使用当前系统内核配置</li>
<li><code>lscpu</code>，查看CPU</li>
<li><code>make -j2 all</code>，编译</li>
<li><code>make modules_install &amp;&amp; make install</code>，安装内核</li>
</ul>
<h2 id="grub配置">grub配置</h2>
<p>配置文件：</p>
<ul>
<li><code>/etc/default/grub</code>，默认配置</li>
<li><code>/etc/grub.d/</code>，详细配置</li>
<li><code>/boot/grub2/grub.cfg</code></li>
<li><code>grub2-mkconfig -o /boot/grub2/grub.cfg</code>，产生新配置文件</li>
</ul>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven学习</title>
    <url>/2022/02/23/Maven%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1>Maven 学习</h1>
<h2 id="Maven-项目构建命令">Maven 项目构建命令</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#编译<br>mvn compile<br># 清理<br>mvn clean<br># 测试<br>mvn test<br># 打包<br>mvn package<br># 安装到本地仓库<br>mvn install<br></code></pre></td></tr></table></figure>
<h2 id="依赖传递冲突问题">依赖传递冲突问题</h2>
<p>路径优先：相同资源，层级越深，优先级越低</p>
<p>声明优先：同层依赖，前面的会覆盖后面的</p>
<p>特殊优先：同级配置了相同资源的不同版本时，后面的覆盖前面的</p>
<h2 id="依赖范围">依赖范围</h2>
<p><img src="https://cdn.jsdelivr.net/gh/xianyuerrr/PicGo/img/Roaming/Typora/typora-user-images/image-20220223202114355.png" alt="image-20220223202114355"></p>
<h2 id="依赖范围的传递性">依赖范围的传递性</h2>
<p><img src="https://cdn.jsdelivr.net/gh/xianyuerrr/PicGo/img/Roaming/Typora/typora-user-images/image-20220223212613952.png" alt="image-20220223212613952"></p>
<h2 id="项目构建生命周期">项目构建生命周期</h2>
<p>Maven对项目构建的生命周期分为三套：</p>
<ul>
<li>clean，清理</li>
<li>default，核心工作（编译、测试、打包、部署）</li>
<li>site，产生报告，发布站点</li>
</ul>
<p><img src="C:/Users/30786/AppData/Roaming/Typora/typora-user-images/image-20220223215124231.png" alt="image-20220223215124231"></p>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown基本语法</title>
    <url>/2020/03/06/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1>Markdown 基础</h1>
<h2 id="1-准备">1 准备</h2>
<h3 id="1-1-前言">1.1 前言</h3>
<p>  最近在看书，突然了解到了一个比较有意思并且有用的语言：<strong>Markdown</strong>。这个语言是用在 <strong>.md</strong> 文件的编写上的。可以比较容易的使用纯文本格式编写出十分美观的文档。</p>
<p>  之前，我准备在 <strong>CSDN</strong> 上写博客的时候，看到写一个博客竟然和写代码一样，还要学习一门新语言，我立马就被劝退了。不过在前两天了解了 <strong>Markdown</strong> 语言之后，才发现这还挺好用。不仅简单，而且对于图片、图表、数学式都有支持。回过头来，突然发现我们的<strong>CSDN</strong>也支持使用 <strong>Markdown</strong> 语言来写博客文章，当初我竟然被这么个语言给劝退了…<br>
<img src="https://img-blog.csdnimg.cn/20201010230612761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODc0ODM0,size_16,color_FFFFFF,t_70#pic_center" width="80%" alt="截图" align=center /></p>
<p>  网上已经有很多十分优秀的 <strong>Markdown</strong> 语言教程了，比如<a href="https://www.runoob.com">菜鸟教程</a>的 <strong>Markdown</strong> 教程。本篇只是记录自己的学习过程，如有错误，还望大家海涵。若能指出错误，在下将十分感激！</p>
<hr>
<h3 id="1-2-编辑器选择">1.2 编辑器选择</h3>
<p>  作为新手，如果你使用纯文本编辑器，比如记事本，带来的问题可不仅仅是不方便这么简单。更致命的一点是在纯文本编辑器中使用 <strong>Markdown</strong> 语言没有即时预览功能，你无法直观的感受到你写出的文档最终会以什么样子呈现出来。所以我比较推荐大家使用具有即使预览功能的编辑器，比如我目前使用的<a href="https://typora.io/">Typora</a>，我觉得就是一款很棒的<strong>Markdown</strong>语言编辑器。由于我刚开始学习，用过的编辑器也不多，不能给出更多的推荐了。</p>
<p>  如果你平常使用<strong>Sublime Text</strong>或者 <strong>VsCode</strong> ，他们虽然没有自带即时预览的功能，但是他们有着十分强大、丰富的社区，你可以通过一系列的折腾来武装你的编辑器，来使他们能够很好的支持你对于<strong>Markdown</strong>语言的使用，这些操作的教程以级实例在网络上可以轻松的找到。其他类似的编辑器也可以进行类似的操作。</p>
<h2 id="2-语法">2 语法</h2>
<h3 id="2-1标题">2.1标题</h3>
<p>使用 <strong>#</strong> 号可表示标题，一级标题对应一个 <strong>#</strong> 号，二级标题对应两个 <strong>#</strong> 号，以此类推。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 一级标题</span><br><span class="hljs-section">## 二级标题</span><br><span class="hljs-section">### 三级标题</span><br><span class="hljs-section">#### 四级标题</span><br></code></pre></td></tr></table></figure>
<p><em>效果如下：</em></p>
<img src="https://cdn.jsdelivr.net/gh/xianyuerrr/PicGo/img/Roaming/Typora/typora-user-images/image-20210127173350005.png" style="zoom:50%;" />
<p>在编辑器Typora里可以使用**Ctrl+[0-6]**来快速设置格式，<strong>Ctrl+0</strong>是设置成段落，1到6是设置成各级标题。</p>
<h3 id="2-2-段落样式">2.2 段落样式</h3>
<h4 id="2-2-1-字体">2.2.1 字体</h4>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">Markdown可以使用以下几种字体：<br><span class="hljs-emphasis">*斜体文本*</span><br><span class="hljs-emphasis">_斜体文本_</span><br><span class="hljs-strong">**粗体文本**</span><br><span class="hljs-strong">__粗体文本__</span><br><span class="hljs-strong">**<span class="hljs-emphasis">*粗斜体文本<span class="hljs-strong">**<span class="hljs-emphasis">*</span></span></span></span><br><span class="hljs-emphasis"><span class="hljs-strong"><span class="hljs-emphasis"><span class="hljs-strong"><span class="hljs-strong">__<span class="hljs-emphasis">_粗斜体文本<span class="hljs-strong">__<span class="hljs-emphasis">_</span></span></span></span></span></span></span></span><br></code></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><em>斜体文本</em></p>
<p><em>斜体文本</em></p>
<p><strong>粗体文本</strong></p>
<p><strong>粗体文本</strong></p>
<p><em><strong>粗斜体文本</strong></em></p>
<p><em><strong>粗斜体文本</strong></em></p>
<h4 id="2-2-2-修饰">2.2.2 修饰</h4>
<p>(1) 分隔线</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">一行内三个以上的星号(<span class="hljs-emphasis">*)、减号(-)、底线(_)，行内不能有其他东西。</span><br><span class="hljs-emphasis">如：<span class="hljs-strong">**<span class="hljs-emphasis">*</span></span></span><br></code></pre></td></tr></table></figure>
<p>效果如下：</p>
<hr>
<p>(2) 删除线</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">文字两端加上两个波浪线~<br>~~xianyue~~<br></code></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><s>xianyue</s></p>
<p>(3) 下划线</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">使用HTML的<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span></span>标签实现<br>如：<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span></span>xianyue<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">u</span>&gt;</span></span><br></code></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><u>xianyue</u></p>
<p>(4) 脚注</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">使用[^文本]的格式实现脚注<br>如：脚注[^xinayue]: xianyue<br></code></pre></td></tr></table></figure>
<p>效果如下：</p>
<p>脚注[^xinayue]</p>
<h3 id="2-3-元素">2.3 元素</h3>
<h4 id="2-3-1-列表">2.3.1 列表</h4>
<p>(1) 无序列表</p>
<p>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">如：<br><span class="hljs-bullet">*</span> 第一项<br><span class="hljs-bullet">*</span> 第二项<br><span class="hljs-bullet">*</span> 第三项<br></code></pre></td></tr></table></figure>
<p>效果如下：</p>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<p>(2) 有序列表</p>
<p>有序列表使用数字并加上 <strong>.</strong> 号来表示。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">如：<br><span class="hljs-bullet">1.</span> 第一项<br><span class="hljs-bullet">2.</span> 第二项<br><span class="hljs-bullet">3.</span> 第三项<br></code></pre></td></tr></table></figure>
<p>效果如下：</p>
<ol>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ol>
<h4 id="2-3-2-区块">2.3.2 区块</h4>
<p>区块引用是在段落开头使用 <strong>&gt;</strong> 符号 ，然后后面紧跟一个<strong>空格</strong>。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-quote">&gt; 最外层</span><br><span class="hljs-quote">&gt; &gt; 第一层嵌套</span><br><span class="hljs-quote">&gt; &gt; &gt; 第二层嵌套</span><br></code></pre></td></tr></table></figure>
<p>效果如下：</p>
<blockquote>
<p>最外层</p>
<blockquote>
<p>第一层嵌套</p>
<blockquote>
<p>第二层嵌套</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="2-3-3-代码">2.3.3 代码</h4>
<p>(1) 段内短代码</p>
<p>可以用反引号把它包起来（<strong>`</strong>）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">如：<br>`print(&quot;HelloWorld!&quot;)`Python代码<br></code></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><code>print(&quot;HelloWorld!&quot;)</code>Python代码</p>
<p>(2) 代码区块</p>
<p>用 <strong>```</strong> 包裹一段代码，并指定一种语言（也可以不指定）。本文多处都在此种方式创造的代码区块内进行说明（比如下面这个区块）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">如：<br>​```python<br>print(&quot;HelloWorld!&quot;)<br></code></pre></td></tr></table></figure>
<p>效果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;HelloWorld!&quot;</span>)<br></code></pre></td></tr></table></figure>
<h4 id="2-3-4-链接">2.3.4 链接</h4>
<p>(1) 通过网址来设置一个链接</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">[<span class="hljs-string">链接名称</span>](<span class="hljs-link">链接地址</span>)<br>如：<br>[<span class="hljs-string">百度</span>](<span class="hljs-link">http://www.baidu.com</span>)<br></code></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><a href="http://www.baidu.com">百度</a></p>
<p>(2) 直接使用链接地址</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="xml">&lt;http://www.baidu.com&gt;</span><br></code></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><a href="http://www.baidu.com">http://www.baidu.com</a></p>
<p>PS：可以使用如下方式达到<code>&lt;http://www.baidu.com&gt;</code>的效果。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">[<span class="hljs-string">http://www.baidu.com</span>](<span class="hljs-link">http://www.baidu.com</span>)<br></code></pre></td></tr></table></figure>
<p><a href="http://www.baidu.com">http://www.baidu.com</a></p>
<p>(3) 通过变量来设置一个链接</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">[<span class="hljs-string">百度</span>][<span class="hljs-symbol">1</span>]<br>[<span class="hljs-symbol">1</span>]:<span class="hljs-link">http://www.baidu.com</span><br></code></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><a href="http://www.baidu.com">百度</a></p>
<h4 id="2-3-5-图片">2.3.5 图片</h4>
<p>(1) Markdown方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">![alt 属性文本](图片地址 &quot;可选标题&quot;)<br>这种方式无法指定图片的高度与宽度<br>如：<br>![alt 刻晴](https://cdn.jsdelivr.net/gh/xianyuerrr/PicGo/img/AppData/Roaming/picgo/20210127182153.png &quot;刻晴&quot;)<br></code></pre></td></tr></table></figure>
<p>效果如下：</p>
<img src="https://cdn.jsdelivr.net/gh/xianyuerrr/PicGo/img/AppData/Roaming/picgo/20210127182153.png" alt="alt 刻晴" title="刻晴" style="zoom:50%;" />
<p>(2) HTML方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xianyuerrr/PicGo/img/AppData/Roaming/picgo/20210127182153.png&quot; alt=&quot;alt 刻晴&quot; title=&quot;刻晴&quot; style=&quot;zoom: 25%;&quot; /&gt;<br></code></pre></td></tr></table></figure>
<p>效果如下：</p>
<img src="https://cdn.jsdelivr.net/gh/xianyuerrr/PicGo/img/AppData/Roaming/picgo/20210127182153.png" alt="alt 刻晴" title="刻晴" style="zoom: 25%;" />
<h4 id="2-3-6-表格">2.3.6 表格</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。<br>如：<br>|  ID   | Password  |<br>|  ----  | ----  |<br>| a  | 123 |<br>| b  | 456 |<br></code></pre></td></tr></table></figure>
<p>效果如下（默认左对齐）：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Password</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>123</td>
</tr>
<tr>
<td>b</td>
<td>456</td>
</tr>
</tbody>
</table>
<p>可以设置表格的对齐方式：</p>
<ol>
<li>“-:”右对齐</li>
<li>“:-”左对齐</li>
<li>“:-:”居中</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">如：<br>|  ID   | Password  |<br>|  ----:  | ----:  |<br>| a  | 123 |<br>| b  | 456 |<br></code></pre></td></tr></table></figure>
<p>效果如下：</p>
<table>
<thead>
<tr>
<th style="text-align:right">ID</th>
<th style="text-align:right">Password</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">a</td>
<td style="text-align:right">123</td>
</tr>
<tr>
<td style="text-align:right">b</td>
<td style="text-align:right">456</td>
</tr>
</tbody>
</table>
<h2 id="3-高级技巧">3 高级技巧</h2>
<h3 id="3-1-HTML支持">3.1 HTML支持</h3>
<p>前面我们已经在<strong>Markdown</strong>里使用了<strong>HTML</strong>标签，其实许多<strong>HTML</strong>标签在<strong>Markdown</strong>都能支持。其实，<strong>Markdown</strong>的表现格式是可以通过<strong>CSS</strong>来进行更改的，<strong>Typora</strong>里的众多主体就是通过使用不同的<strong>CSS</strong>文件来达成的。还有，你如果在<strong>Typora</strong>里打开了调试模式，右键点击<strong>检查元素</strong>，然后你会发现这和网页源代码有着惊人的相似度。这也就不难想象<strong>Markdown</strong>与<strong>HTML</strong>、<strong>CSS</strong>之间的密切联系了。</p>
<h3 id="3-2-转义">3.2 转义</h3>
<p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">\   反斜线<br>`   反引号<br>*   星号<br>_   下划线<br>&#123;&#125;  花括号<br>[]  方括号<br>()  小括号<br>#   井字号<br>+   加号<br>-   减号<br>.   英文句点<br>!   感叹号<br></code></pre></td></tr></table></figure>
<h3 id="3-3-Tex支持">3.3 Tex支持</h3>
<p>当你需要在编辑器中插入数学公式时，可以使用美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">$$<br>\mathbf&#123;V&#125;_1 \times \mathbf&#123;V&#125;_2 =  \begin&#123;vmatrix&#125; <br>\mathbf&#123;i&#125; &amp; \mathbf&#123;j&#125; &amp; \mathbf&#123;k&#125; \\<br>\frac&#123;\partial X&#125;&#123;\partial u&#125; &amp;  \frac&#123;\partial Y&#125;&#123;\partial u&#125; &amp; 0 \\<br>\frac&#123;\partial X&#125;&#123;\partial v&#125; &amp;  \frac&#123;\partial Y&#125;&#123;\partial v&#125; &amp; 0 \\<br>\end&#123;vmatrix&#125;<br>$$<br></code></pre></td></tr></table></figure>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BV%7D_1%20%5Ctimes%20%5Cmathbf%7BV%7D_2%20%3D%20%20%5Cbegin%7Bvmatrix%7D%20%0A%5Cmathbf%7Bi%7D%20%26%20%5Cmathbf%7Bj%7D%20%26%20%5Cmathbf%7Bk%7D%20%5C%5C%0A%5Cfrac%7B%5Cpartial%20X%7D%7B%5Cpartial%20u%7D%20%26%20%20%5Cfrac%7B%5Cpartial%20Y%7D%7B%5Cpartial%20u%7D%20%26%200%20%5C%5C%0A%5Cfrac%7B%5Cpartial%20X%7D%7B%5Cpartial%20v%7D%20%26%20%20%5Cfrac%7B%5Cpartial%20Y%7D%7B%5Cpartial%20v%7D%20%26%200%20%5C%5C%0A%5Cend%7Bvmatrix%7D%0A" /></p><h2 id="附录-：">附录 ：</h2>
<h3 id="1、横向流程图：">1、横向流程图：</h3>
<pre class="mermaid">graph LR
A[方形] -->B(圆角)
    B --> C{条件a}
    C -->|a=1| D[结果1]
    C -->|a=2| E[结果2]
    F[横向流程图]</pre>
<h3 id="2、竖向流程图">2、竖向流程图</h3>
<pre class="mermaid">graph TD
A[方形] --> B(圆角)
    B --> C{条件a}
    C --> |a=1| D[结果1]
    C --> |a=2| E[结果2]
    F[竖向流程图]</pre>
<h3 id="3、标准流程图">3、标准流程图</h3>
<div id="flowchart-0" class="flow-chart"></div>
<div id="flowchart-1" class="flow-chart"></div>
<h3 id="4、-UML时序图">4、 UML时序图</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs sequence">对象A-&gt;对象B: 对象B你好吗?（请求）<br>Note right of 对象B: 对象B的描述<br>Note left of 对象A: 对象A的描述(提示)<br>对象B--&gt;对象A: 我很好(响应)<br>对象A-&gt;对象B: 你真的好吗？<br></code></pre></td></tr></table></figure>
<h3 id="5、标准UML时序图">5、标准UML时序图</h3>
<pre class="mermaid">%% 时序图例子,-> 直线，-->虚线，->>实线箭头
  sequenceDiagram
    participant 张三
    participant 李四
    张三->王五: 王五你好吗？
    loop 健康检查
        王五->王五: 与疾病战斗
    end
    Note right of 王五: 合理 食物 <br/>看医生...
    李四-->>张三: 很好!
    王五->李四: 你怎么样?
    李四-->王五: 很好!</pre>
<h3 id="6、甘特图">6、甘特图</h3>
<pre class="mermaid">%% 语法示例
        gantt
        dateFormat  YYYY-MM-DD
        title 软件开发甘特图
        section 设计
        需求                      :done,    des1, 2014-01-06,2014-01-08
        原型                      :active,  des2, 2014-01-09, 3d
        UI设计                     :         des3, after des2, 5d
    未来任务                     :         des4, after des3, 5d
        section 开发
        学习准备理解需求                      :crit, done, 2014-01-06,24h
        设计框架                             :crit, done, after des2, 2d
        开发                                 :crit, active, 3d
        未来任务                              :crit, 5d
        耍                                   :2d
        section 测试
        功能测试                              :active, a1, after des3, 3d
        压力测试                               :after a1  , 20h
        测试报告                               : 48h</pre>
<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: 开始框
op=>operation: 处理框
cond=>condition: 判断框(是或否?)
sub1=>subroutine: 子流程
io=>inputoutput: 输入输出框
e=>end: 结束框
st->op->cond
cond(yes)->io->e
cond(no)->sub1(right)->op</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><textarea id="flowchart-1-code" style="display: none">st=>start: 开始框
op=>operation: 处理框
cond=>condition: 判断框(是或否?)
sub1=>subroutine: 子流程
io=>inputoutput: 输入输出框
e=>end: 结束框
st(right)->op(right)->cond
cond(yes)->io(bottom)->e
cond(no)->sub1(right)->op</textarea><textarea id="flowchart-1-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-1", options);</script>]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 笔记</title>
    <url>/2020/12/01/MySQL-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1>MySql 笔记</h1>
<h2 id="基础">基础</h2>
<h3 id="DB、DBMS、SQL">DB、DBMS、SQL</h3>
<p><strong>数据库</strong>：<br>
DataBase，简称 DB。顾名思义，存储数据的仓库，实际上就是一堆文件。这些文件中存储了具有特定格式的数据。</p>
<p><strong>数据库管理系统</strong>：<br>
DataBase Management System，简称 DBMS。专门用来管理数据库中数据的，数据库管理系统可以对数据库当中的数据进行增删改查。</p>
<p>常见的数据库管理系统：<br>
MySQL、Oracle、SQL Server、DB2等…</p>
<p><strong>SQL</strong>：结构化查询语言<br>
SQL 是一套标准，程序员通过编写 SQL 语句，使 DBMS 负责执行 SQL 语句，最终来完成数据库中数据的增删改查操作。</p>
<p>三者之间的关系？<br>
DBMS – 执行 --&gt; SQL – 操作 --&gt; DB</p>
<h3 id="常用命令">常用命令</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># Win 开启服务<br>net stop 服务名称;<br><br># Win 关闭服务<br>net start 服务名称;<br><br># MySQL 登录<br>mysql -uroot -p<br></code></pre></td></tr></table></figure>
<h3 id="SQL-语句的分类">SQL 语句的分类</h3>
<pre><code>DQL：
	数据查询语言（凡是带有select关键字的都是查询语句）
	select...

DML：
	数据操作语言（凡是对表当中的数据进行增删改的都是DML）
	insert delete update
	insert 增
	delete 删
	update 改

	这个主要是操作表中的数据data。

DDL：
	数据定义语言
	凡是带有create、drop、alter的都是DDL。
	DDL主要操作的是表的结构。不是表中的数据。
	create：新建，等同于增
	drop：删除
	alter：修改
	这个增删改和DML不同，这个主要是对表结构进行操作。

TCL：
	是事务控制语言
	包括：
		事务提交：commit;
		事务回滚：rollback;

DCL：
	是数据控制语言。
	例如：授权grant、撤销权限revoke....
</code></pre>
<h3 id="单行处理函数">单行处理函数</h3>
<ul>
<li>upper 转换大写</li>
<li>lower 转换小写</li>
<li>substr 取子串</li>
<li>concat 字符串拼接</li>
<li>length 去空格</li>
<li>str_to_date 将字符串转换成日期</li>
<li>date_format 格式化日期</li>
<li>format 设置千分位</li>
<li>round 四舍五入</li>
<li>rand 生成随机数</li>
<li>ifnull</li>
</ul>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Python math库常用函数</title>
    <url>/2020/04/06/Python-math%E5%BA%93%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1>Python-math库 常用函数</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> *<br></code></pre></td></tr></table></figure>
<h2 id="常量">常量</h2>
<ol>
<li><code>e</code>：数学常数 <em>e</em> = 2.718281…，精确到可用精度</li>
<li><code>pi</code>：数学常数 <em>π</em> = 3.141592…，精确到可用精度</li>
<li><code>inf</code>：浮点正无穷大，相当于 <code>float('inf')</code></li>
<li><code>nan</code>：浮点“非数字”（NaN）值，相当于 <code>float('nan')</code></li>
<li><code>tau</code>：数学常数 <em>τ</em>，等于 2<em>π</em></li>
</ol>
<h2 id="数论与表示函数">数论与表示函数</h2>
<ol>
<li><code>ceil(x)</code>：上取整</li>
<li><code>floor(x)</code>：下取整</li>
<li><code>factorial(x)</code>：阶乘</li>
<li><code>comb(n, k)</code> ：<img src="https://math.now.sh?inline=C_%7Bn%7D%5E%7Bk%7D" style="display:inline-block;margin: 0;"/></li>
<li><code>perm(n, k=None)</code>：<img src="https://math.now.sh?inline=A_%7Bn%7D%5E%7Bk%7D" style="display:inline-block;margin: 0;"/></li>
<li><code>gcd(a, b)</code>：最大公约数</li>
<li><code>fsum(iterable)</code>：精确浮点值，比 <strong>sum</strong> 更精确</li>
<li><code>fabs(x)</code>：绝对值</li>
<li><code>prod(iterable, *, start=1)</code>：计算输入的 <em>iterable</em> 中所有元素的积。 积的默认 <em>start</em> 值为 <code>1</code>。</li>
<li><code>fmod(x, y)</code>：取余。 <a href="https://docs.python.org/zh-cn/3.8/library/math.html#math.fmod"><code>fmod()</code></a> 在使用浮点数时是首选， <code>x % y</code> 在使用整数时是首选。</li>
<li><code>copysign(x, y)</code>：基于 <strong><em>x</em> 的绝对值</strong>和 <strong><em>y</em> 的符号</strong>的浮点数</li>
<li><code>frexp(x)</code>：以 <code>(m, e)</code> 对的形式返回 <em>x</em> 的尾数和指数。 <em>m</em> 是一个浮点数， <em>e</em> 是一个整数。正好是 <code>x == m * 2**e</code></li>
<li><code>isclose(a, b, *, rel_tol=le-09, abs_tol=0.0)</code>：a, b是否接近。</li>
</ol>
<h2 id="幂函数与对数函数">幂函数与对数函数</h2>
<ol>
<li><code>exp(x)</code>：<img src="https://math.now.sh?inline=e%5E%7Bx%7D" style="display:inline-block;margin: 0;"/></li>
<li><code>log(x, y=e)</code>：以 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 为底 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 的对数</li>
<li><code>log1p(x)</code>： <img src="https://math.now.sh?inline=x%2B1" style="display:inline-block;margin: 0;"/> 的自然对数（<img src="https://math.now.sh?inline=e" style="display:inline-block;margin: 0;"/> 为底）</li>
<li><code>log2(x)</code> ：以 <img src="https://math.now.sh?inline=2" style="display:inline-block;margin: 0;"/> 为底 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 的对数，通常比 <code>log(x, 2)</code> 更准确</li>
<li><code>log10(x)</code> ：以 <img src="https://math.now.sh?inline=10" style="display:inline-block;margin: 0;"/> 为底 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 的对数，通常比 <code>log(x, 10)</code> 更准确</li>
<li><code>pow(x, y)</code>：<img src="https://math.now.sh?inline=x%5E%7By%7D" style="display:inline-block;margin: 0;"/> ，与内置的 <code>**</code> 运算符不同， <a href="https://docs.python.org/zh-cn/3/library/math.html#math.pow"><code>math.pow()</code></a> 将其参数转换为 <a href="https://docs.python.org/zh-cn/3/library/functions.html#float"><code>float</code></a> 类型。使用 <code>**</code> 或内置的 <a href="https://docs.python.org/zh-cn/3/library/functions.html#pow"><code>pow()</code></a> 函数来计算精确的整数幂。</li>
<li><code>sqrt(x)</code>：<img src="https://math.now.sh?inline=%5Csqrt%7Bx%7D" style="display:inline-block;margin: 0;"/></li>
</ol>
<h2 id="三角函数">三角函数</h2>
<ol>
<li><code>acos(x)</code>：以弧度为单位返回 <em>x</em> 的反余弦值</li>
<li><code>asin(x)</code>：以弧度为单位返回 <em>x</em> 的反正弦值</li>
<li><code>atan(x)</code>：以弧度为单位返回 <em>x</em> 的反正切值</li>
<li><code>atan2(y, x)</code>：以弧度为单位返回 <code>atan(y / x)</code></li>
<li><code>sin(x)</code>：返回 <em>x</em> 弧度的正弦值</li>
<li><code>cos(x)</code>：返回 <em>x</em> 弧度的余弦值</li>
<li><code>tan(x)</code>：返回 <em>x</em> 弧度的正切值</li>
<li><code>dist(p, q)</code>：返回 <em>p</em> 与 <em>q</em> 两点之间的欧几里得距离。<code>sqrt(sum((px - qx) ** 2.0 for px, qx in zip(p, q)))</code></li>
<li><code>hypot(*coordinates)</code>：欧几里得范数。<code>sqrt(sum(x**2 for x in coordinates))</code></li>
</ol>
<h2 id="角度转换">角度转换</h2>
<ol>
<li><code>degrees(x)</code>：将角度 <em>x</em> 从弧度转换为度数</li>
<li><code>radians(x)</code>：将角度 <em>x</em> 从度数转换为弧度</li>
</ol>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>math</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 字符串常用函数</title>
    <url>/2020/11/30/Python-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1>Python字符操作</h1>
<h2 id="ASCII">ASCII</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-comment"># 97</span><br><span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;z&#x27;</span>) <span class="hljs-comment"># 122</span><br><span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;A&#x27;</span>) <span class="hljs-comment"># 65</span><br><span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;Z&#x27;</span>) <span class="hljs-comment"># 90</span><br></code></pre></td></tr></table></figure>
<h2 id="判断字符串">判断字符串</h2>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">s.isalnum() #所有字符都是数字或者字母<br>s.isalpha() #所有字符都是字母<br>s.isdigit() #所有字符都是数字<br>s.islower() #所有字符都是小写<br>s.isupper() #所有字符都是大写<br>s.istitle() #所有单词都是首字母大写，像标题<br>s.isspace() #所有字符都是空白字符、\t、\n<br></code></pre></td></tr></table></figure>
<h2 id="大小写转换">大小写转换</h2>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">s.upper() #把所有字符中的小写字母转换成大写字母<br>s.lower() #把所有字符中的大写字母转换成小写字母<br>s.capitalize() #把第一个字母转化为大写字母，其余小写<br>s.title() #把每个单词的第一个字母转化为大写，其余小写<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python之禅</title>
    <url>/2019/11/06/Python%E4%B9%8B%E7%A6%85/</url>
    <content><![CDATA[<h1>Python之禅</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> this<br>The Zen of Python, by Tim Peters<br><br>Beautiful <span class="hljs-keyword">is</span> better than ugly.<br>Explicit <span class="hljs-keyword">is</span> better than implicit.<br>Simple <span class="hljs-keyword">is</span> better than <span class="hljs-built_in">complex</span>.<br>Complex <span class="hljs-keyword">is</span> better than complicated.<br>Flat <span class="hljs-keyword">is</span> better than nested.<br>Sparse <span class="hljs-keyword">is</span> better than dense.<br>Readability counts.<br>Special cases aren<span class="hljs-string">&#x27;t special enough to break the rules.</span><br><span class="hljs-string">Although practicality beats purity.</span><br><span class="hljs-string">Errors should never pass silently.</span><br><span class="hljs-string">Unless explicitly silenced.</span><br><span class="hljs-string">In the face of ambiguity, refuse the temptation to guess.</span><br><span class="hljs-string">There should be one-- and preferably only one --obvious way to do it.</span><br><span class="hljs-string">Although that way may not be obvious at first unless you&#x27;</span>re Dutch.<br>Now <span class="hljs-keyword">is</span> better than never.<br>Although never <span class="hljs-keyword">is</span> often better than *right* now.<br>If the implementation <span class="hljs-keyword">is</span> hard to explain, it<span class="hljs-string">&#x27;s a bad idea.</span><br><span class="hljs-string">If the implementation is easy to explain, it may be a good idea.</span><br><span class="hljs-string">Namespaces are one honking great idea -- let&#x27;</span>s do more of those!<br></code></pre></td></tr></table></figure>
<ol>
<li>
<p>优美胜于丑陋（以优美为目标）</p>
</li>
<li>
<p>明了胜于晦涩</p>
</li>
<li>
<p>简洁胜于复杂（尽量不要有复杂的内部实现）</p>
</li>
<li>
<p>复杂胜于凌乱（就算复杂是不可避免的，也要保证代码之间没有难懂的关系）</p>
</li>
<li>
<p>扁平胜于嵌套（不要有太多嵌套）</p>
</li>
<li>
<p>间隔胜于紧凑（不要写的太挤）</p>
</li>
<li>
<p>可读性很重要</p>
</li>
<li>
<p>这些规则不可违背</p>
</li>
<li>
<p>不要无故忽视异常（不写 expect: pass 风格的代码，除非你确定要这样）</p>
</li>
<li>
<p>做之前要先思考，立刻着手好过永远不做。然而，永远不做也好过闷头蛮干</p>
</li>
<li>
<p>方案思路要清晰，倘若你的实现很难解释，它<strong>一定不是</strong>个好主意。倘若你的实现一目了然，它<strong>可能是</strong>个好主意。</p>
</li>
<li>
<p>命名空间大法好，同志们要多多搞。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis基础</title>
    <url>/2021/12/28/Redis%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1>Redis 基础</h1>
<h2 id="基本介绍">基本介绍</h2>
<p>Redis 是一个开源的<strong>内存中</strong>的数据结构存储系统，可以用作数据库、缓存和消息中间件 MQ。</p>
<p>Redis 很快，其基于内存操作，CPU 不是其性能瓶颈，其瓶颈是内存和网络带宽，所以其使用的是单线程（没必要用多线程）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 测试连接<br>ping<br><br># 新建 kv 对<br>set key value<br>setex(set with expire) key time value<br>setnx(set if not exist) key value<br># 新建多个 KV 对，原子性操作<br>mset [key1 value1 key2 value2]<br>msetnx [key1 value1 key2 value2]<br><br># key 是否存在<br>exists key<br><br># 得到 key 对应的 value<br>get key<br>mget [key1 value1 key2 value2]<br><br># 移动 key 到 1 号数据库<br>move key 1<br><br># 列出所有 key<br>keys *<br><br># 设置 key 过期时间<br>expire key<br><br># 查看 key 类型<br>type key<br><br># 清除当前数据库内容<br>FlushDb<br># 清除数据库内容（共 16 个）<br>FlushAll<br></code></pre></td></tr></table></figure>
<h2 id="数据类型">数据类型</h2>
<h3 id="String">String</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">strlen key<br>append key str<br><br># 自增<br>incr key<br># 自减<br>decr key<br># 自增 step<br>incrby step key<br># 自减 step<br>decrby step key<br># 切片 [start, end]<br>getrange key start end<br>setrange key start end<br></code></pre></td></tr></table></figure>
<h2 id="List">List</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 添加元素<br>LPush RPush<br><br># 移除元素<br>LPop RPop<br><br># 移除 n 个元素<br>LRem list n value<br>RRem list n value<br><br># 删除 list[start, end]<br>L<br><br># 返回 list[start, end]<br>LRange list start end<br><br># 返回 list 长度<br>LLen list<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>SwitchHosts使用</title>
    <url>/2024/03/10/SwitchHosts%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1>SwitchHosts使用</h1>
<h2 id="Hosts是什么">Hosts是什么</h2>
<p>当浏览器要访问一个网站时，我们通常使用域名（形如：<a href="https://www.baidu.com">https://www.baidu.com</a>）来访问网络资源。但Internet是使用IP地址（形如：127.0.0.1）来标识站点的。所以它首先需要将网站的域名解析成其对应的IP地址，这个过程是通过DNS服务器来完成的。然后，浏览器才能根据这个IP地址定位到网站并访问其数据。</p>
<p>本地计算机存储域名对应ip的文件就是hosts文件，它将一些常用的网址<a href="https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D/86062?fromModule=lemma_inlink">域名</a>与其对应的<a href="https://baike.baidu.com/item/IP%E5%9C%B0%E5%9D%80/0?fromModule=lemma_inlink">IP地址</a>建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会首<strong>先自动从Hosts文件</strong>中寻找对应的<a href="https://baike.baidu.com/item/IP%E5%9C%B0%E5%9D%80/0?fromModule=lemma_inlink">IP地址</a>，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会<strong>再将网址提交DNS域名解析服务器</strong>进行IP地址的解析。</p>
<p>所以我们可以通过更改hosts文件, 改变浏览器请求特定域名的资源时，对应访问的服务器。在网站开发中可以通过修改hosts文件，来模拟全仿真的测试环境。</p>
<h2 id="SwitchHosts">SwitchHosts</h2>
<p>SwitchHosts 是一个管理、切换hosts的工具，能够自定义多份hosts文件配置并灵活切换与组合，且支持语法高亮。</p>
<p><a href="https://switchhosts.vercel.app/zh">SwitchHosts官网</a>，在官网进行下载，以管理员身份运行即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xianyuerrr/PicGo/picgo/image-20240310163441289.png" alt="image-20240310163441289"></p>
<h2 id="常见问题">常见问题</h2>
<ol>
<li>
<p>无法编辑hosts文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/xianyuerrr/PicGo/picgo/image-20240310161631989.png" alt="image-20240310161631989"></p>
<p>以管理员身份运行SwitchHosts</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>host</tag>
      </tags>
  </entry>
  <entry>
    <title>TopK问题</title>
    <url>/2021/12/02/TopK%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1>TOPK</h1>
<p>整体排序</p>
<p>1、冒泡，O（N2）</p>
<p>2、堆排序，O（NLogN）</p>
<p>3、快排，O（NLogN）</p>
<p>4、计数排序（数据范围不能太大，空间换时间），O（N）</p>
<p>局部排序</p>
<p>1、局部冒泡（找完最大K个就停止），O（KN）</p>
<p>2、小根堆，依次遍历，把最大的K个数放进去，O（NLogK）</p>
<p>3、局部快排（可随机选取pivot）只排序包含第K大的那一侧，平均 O（N）</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>biset 二分查找</title>
    <url>/2020/04/10/biset-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h1>Python： <a href="https://docs.python.org/zh-cn/3.7/library/bisect.html#module-bisect"><code>bisect</code></a> — 数组二分查找算法</h1>
<h2 id="查找">查找</h2>
<p><code>bisect_left</code>(<em>a</em>, <em>x</em>, <em>lo=0</em>, <em>hi=len(a)</em>)</p>
<p>从idx开始都是 大于等于 target 的（左侧都小于）</p>
<p>数组名，值，区间 [lo, hi)</p>
<p>在 <em>a</em> 中找到 <em>x</em> 合适的插入点以维持有序。参数 <em>lo</em> 和 <em>hi</em> 可以被用于确定需要考虑的子集；默认情况下整个列表都会被使用。如果 <em>x</em> 已经在 <em>a</em> 里存在，那么插入点会在已存在元素之前（也就是左边）。如果 <em>a</em> 是列表（list）的话，返回值是可以被放在 <code>list.insert()</code> 的第一个参数的。</p>
<p>返回的插入点 <em>i</em> 可以将数组 <em>a</em> 分成两部分。左侧是 <code>all(val &lt; x for val in a[lo:i])</code> ，右侧是 <code>all(val &gt;= x for val in a[i:hi])</code> 。</p>
<p><code>bisect_right</code>(<em>a</em>, <em>x</em>, <em>lo=0</em>, <em>hi=len(a)</em>)</p>
<p>从idx开始往右都是 大于 target 的（左侧都小于等于）</p>
<p><code>bisect</code>(<em>a</em>, <em>x</em>, <em>lo=0</em>, <em>hi=len(a)</em>)</p>
<p>类似于 <a href="https://docs.python.org/zh-cn/3.7/library/bisect.html#bisect.bisect_left"><code>bisect_left()</code></a>，但是返回的插入点是 <em>a</em> 中已存在元素 <em>x</em> 的右侧。</p>
<p>返回的插入点 <em>i</em> 可以将数组 <em>a</em> 分成两部分。左侧是 <code>all(val &lt;= x for val in a[lo:i])</code>，右侧是 <code>all(val &gt; x for val in a[i:hi])</code> for the right side。</p>
<h2 id="插入">插入</h2>
<p><code>insort_left</code>(<em>a</em>, <em>x</em>, <em>lo=0</em>, <em>hi=len(a)</em>)</p>
<p>将 <em>x</em> 插入到一个有序序列 <em>a</em> 里，并维持其有序。如果 <em>a</em> 有序的话，这相当于 <code>a.insert(bisect.bisect_left(a, x, lo, hi), x)</code>。要注意搜索是 O(log n) 的，插入却是 O(n) 的。</p>
<p><code>insort_right</code>(<em>a</em>, <em>x</em>, <em>lo=0</em>, <em>hi=len(a)</em>)</p>
<p><code>insort</code>(<em>a</em>, <em>x</em>, <em>lo=0</em>, <em>hi=len(a)</em>)</p>
<p>类似于 <a href="https://docs.python.org/zh-cn/3.7/library/bisect.html#bisect.insort_left"><code>insort_left()</code></a>，但是把 <em>x</em> 插入到 <em>a</em> 中已存在元素 <em>x</em> 的右侧。</p>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Python</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>bit与Byte</title>
    <url>/2020/11/03/bit%E4%B8%8EByte/</url>
    <content><![CDATA[<h1>计算机网络—bit与Byte</h1>
<h2 id="bit">bit</h2>
<p>  <strong>速率</strong>是衡量计算机网络性能的一个重要指标。速率指的是数据的传送速率，也称为<strong>数据率</strong>或<strong>比特率</strong>。</p>
<p>速率的单位是<strong>bit/s</strong>(比特每秒)(或者b/s，有时也写为bps，即bit per second)。当数据率较高时，常常在bit/s前面加上一个字母。比如 :</p>
<ul>
<li>
<p><img src="https://math.now.sh?inline=k%28kilo%29%20%3D%2010%5E%7B3%7D%20%3D%20%E5%8D%83" style="display:inline-block;margin: 0;"/></p>
</li>
<li>
<p><img src="https://math.now.sh?inline=M%28Mega%29%20%3D%2010%5E%7B6%7D%20%3D%20%E5%85%86" style="display:inline-block;margin: 0;"/></p>
</li>
<li>
<p><img src="https://math.now.sh?inline=G%28Giga%29%20%3D%2010%5E%7B9%7D%20%3D%20%E5%90%89" style="display:inline-block;margin: 0;"/> (我宿舍光猫上就是吉比特光猫)</p>
</li>
<li>
<p><img src="https://math.now.sh?inline=T%28Tera%29%20%3D%2010%5E%7B12%7D%20%3D%20%E5%A4%AA" style="display:inline-block;margin: 0;"/></p>
</li>
<li>
<p><img src="https://math.now.sh?inline=P%28Peta%29%20%3D%2010%5E%7B15%7D%20%3D%20%E6%8B%8D" style="display:inline-block;margin: 0;"/></p>
</li>
<li>
<p><img src="https://math.now.sh?inline=E%28Exa%29%20%3D%2010%5E%7B18%7D%20%3D%20%E8%89%BE" style="display:inline-block;margin: 0;"/></p>
</li>
<li>
<p><img src="https://math.now.sh?inline=Z%28Zetta%29%20%3D%2010%5E%7B21%7D%20%3D%20%E6%B3%BD" style="display:inline-block;margin: 0;"/></p>
</li>
<li>
<p><img src="https://math.now.sh?inline=Y%28Yotta%29%20%3D%2010%5E%7B24%7D%20%3D%20%E5%B0%A7" style="display:inline-block;margin: 0;"/></p>
</li>
</ul>
<p>现在人们谈到网络速率时，经常省略了速率单位中的<strong>bit/s</strong>，直接叫<strong>100M</strong>之类的，这就容易与字节<strong>Byte</strong>产生混淆。</p>
<h2 id="Byte">Byte</h2>
<p><strong>字节</strong>(Byte)，通常用作<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA">计算机</a>信息计量单位，是通信和数据存储的概念。</p>
<center>1 byte  =  8 bit</center>
<p>字节(Byte)可缩写成B，例如MB表示<a href="https://zh.wikipedia.org/wiki/%E7%99%BE%E4%B8%87%E5%AD%97%E8%8A%82">Megabyte</a>；<a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%85%83">比特</a>（Bit）可缩写成b，例如Mb表示<a href="https://zh.wikipedia.org/w/index.php?title=Megabit&amp;action=edit&amp;redlink=1">Megabit</a>。</p>
<ul>
<li><img src="https://math.now.sh?inline=1MB%20%3D%202%5E%7B20%7DByte%20%3D%208%2C388%2C608bit" style="display:inline-block;margin: 0;"/></li>
<li><img src="https://math.now.sh?inline=1Mb%20%3D%2010%5E%7B6%7Dbit" style="display:inline-block;margin: 0;"/></li>
</ul>
<p>在日常生活中，安装100M的宽带，100M指的是100Mbit/s，而我们手机上通常最高只能达到约 11.9MByte/s​ 的下载速度，四舍五入也就是12MByte/s。我们手机上显示的下载速度也是使用<strong>MB</strong>作为单位的。所以，不是运营商虚假描述，限制了带宽。是人们容易把这两个单位弄混。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计网</tag>
        <tag>bit</tag>
        <tag>Byte</tag>
      </tags>
  </entry>
  <entry>
    <title>for 循环与 stream 流</title>
    <url>/2022/03/16/for-%E5%BE%AA%E7%8E%AF%E4%B8%8E-stream-%E6%B5%81/</url>
    <content><![CDATA[<h1>异或运算性质</h1>
<ol>
<li><code>x ^ 0 = x</code></li>
<li><code>x ^ x = 0</code></li>
<li><code>y ^ x ^ x = y ^ (x ^ x)</code></li>
</ol>
<p>根据以上三条性质可得：<code>y ^ x ^ x = y ^ 0 = y</code></p>
<p>由题可得：除了某个元素只出现一次以外，其余每个元素均出现两次。</p>
<p>所以对整个非空数组的元素进行异或运算，所得结果就等于要求的只出现一次的元素的值。</p>
<h1>实现</h1>
<h2 id="for-循环实现">for 循环实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>​    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>​    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>​      res ^= num;<br>​    &#125;<br>​    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>执行时间：1ms</p>
<h2 id="stream-实现">stream 实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>​    <span class="hljs-comment">// 异或运算</span><br>​    <span class="hljs-keyword">int</span> res = Arrays.stream(nums).reduce(<span class="hljs-number">0</span>, (x, y) -&gt; x ^ y);<br>​    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>执行时间：3ms</p>
<h1>总结思考</h1>
<p>可以发现：for 循环比 stream 运算要快上很多。</p>
<p>for 循环是比较底层的操作，优化很多。对于int[] 类型的数组中的运算受到 JIT 友好以及缓存友好这两个因素决定。</p>
<p>而 stream 的优势是并行处理。数据量越大，stream 的优势越明显，数据量小，还是 for 循环性能好。</p>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo配置latex支持</title>
    <url>/2021/11/06/hexo%E9%85%8D%E7%BD%AElatex%E6%94%AF%E6%8C%81/</url>
    <content><![CDATA[<p>很怪，使用debug模式开启了次服务器，然后代码高亮就正常了…</p>
]]></content>
      <categories>
        <category>hexo配置</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>map和set</title>
    <url>/2020/10/02/map%E5%92%8Cset/</url>
    <content><![CDATA[<h1>映射和集合</h1>
<p>Map 接口定义映射，存储一组键值对的映射关系。</p>
<p>Set 接口定义集合，存储一组互不相同的元素，该接口继承了 Collection 接口。</p>
<h2 id="Map-接口的概念和常用方法">Map 接口的概念和常用方法</h2>
<p>Map 接口存储一组键值对的映射关系，映射中的每个键对应一个值。映射中<strong>不能有重复的键</strong>，否则会出现一个键对应多个值的情况，这违背了映射的定义。</p>
<h2 id="Map-接口的实现类">Map 接口的实现类</h2>
<h3 id="HashMap">HashMap</h3>
<p>HashMap 类是散列映射，通过散列函数计算键对应的存储位置，因此可以快速地完成放置键值对、删除键值对、根据键获得值的操作。</p>
<p>JDK 1.8 之前的 HashMap 的底层通过<strong>数组和链表</strong>实现，如果出现冲突则通过<strong>拉链法</strong>解决冲突。JDK 1.8 在解决冲突时的实现有较大变化，当链表长度大于阈值（默认为 8）时，将链表转化为<strong>红黑树</strong>，以减少搜索时间。</p>
<p><img src="https://raw.githubusercontent.com/xianyuerrr/PicGo/main/img/20210915110838.png" alt="image-20210915110838014"></p>
<p><strong>默认加载因子为什么选择 0.75：</strong></p>
<p>空间利用率与查询成本的一个折中。加载因子过高，空间利用率提高，但哈希冲突的概率增加；加载因子过低，哈希冲突概率降低，但会频繁扩容，空间利用率降低。</p>
<p>0.75 是居于数学分析（泊松分布）和行业规定一起得到的一个结论。</p>
<p><strong>为什么链表转红黑树的阈值设为 8：</strong></p>
<p>为什么不一开始直接使用红黑树</p>
<ol>
<li>红黑树结点所占空间是普通节点的两倍，但查找复杂度低，只有当节点特别多时，红黑树的优点才能够凸显出来。</li>
<li>阈值为 8，是数据分析统计得到的结果。链表长度到达 8 的概率是非常低的。</li>
<li>链表转为红黑树，除了要求链表长度大于 8，还要 HashMap 的<strong>数组长度大于 64</strong>。当红黑树的节点小于或等于 6 个以后，又会恢复为链表形态</li>
</ol>
<p><strong>扩容：</strong></p>
<ol>
<li>初始值 16，负载因子 0.75，阈值 = 负载因子 <code>*</code> 容量；</li>
<li>键值对数目大于阈值 或 初始化时，调用 <code>resize()</code> 进行扩容；</li>
<li>每次扩容都是之前的两倍；</li>
<li>由于hash值范围太大，不能直接在内存建立这么大的数组，所以需要取余。</li>
<li>扩容时判断 <code>e.hash &amp; oldCap</code> 是否为 0。若为 0，则位置不变，若为 1，则位置变为 原位置 + 旧容量。因为当前位置是 hash值对 oldCap 取余得到的，而 oldCap 是 2 的幂次，<code>e.hash % oldCap</code> 相当于 <code>e.hash &amp; (oldCap - 1)</code>，此时容量变为原来的两倍，则运算变为 <code>e.hash &amp; (2*oldCap - 1)</code> 。其实与之前的 <code>&amp;</code> 运算只多了一个二进制位的运算，这个多出来的位，正是 oldCap 的二进制中 1 的位置。所以只需要判断 <code>e.hash &amp; oldCap</code> 即可得到新的位置。</li>
</ol>
<p><strong>能否使用任意类作为 key</strong></p>
<p>可以，但需要注意：</p>
<ol>
<li>重写 <code>equals()</code> 方法时，也应该重写 <code>hashCode()</code> 方法</li>
<li>key 最好使用不可变类型，不会出现<strong>放入和获取时哈希值不同</strong>的情况。对应的哈希值可以被缓存起来，性能好</li>
</ol>
<h3 id="HashTable">HashTable</h3>
<p>Hashtable 类是<strong>散列表</strong>，其功能和 HashMap 相似。以下是 HashMap 和 Hashtable 的部分区别。</p>
<h3 id="HashMap-与-HashTable-的区别">HashMap 与 HashTable 的区别</h3>
<p><strong>HashMap 不是线程安全的</strong>，Hashtable 的大多数方法用关键字 synchronized 修饰，因此 <strong>Hashtable 是线程安全</strong>的。</p>
<p>在不需要保证线程安全的情况下，HashMap 的效率高于 Hashtable。</p>
<p><strong>HashMap 允许键或值为 null</strong>，只能有一个键为 null，可以有一个或多个键对应的值为 null，Hashtable 不允许键或值为 null。</p>
<p>从 JDK 1.8 开始，HashMap 在链表长度大于阈值（默认为 8）时，将链表转化为红黑树以减少搜索时间，Hashtable 没有这样的机制。</p>
<h3 id="ConcurrentHashMap">ConcurrentHashMap</h3>
<p><img src="https://raw.githubusercontent.com/xianyuerrr/PicGo/main/img/20210915125504.png" alt="image-20210915125504735"></p>
<h3 id="TreeMap">TreeMap</h3>
<p>TreeMap 是有序映射，键可以使用 Comparable 接口或 Comparator 接口排序。</p>
<p>TreeMap 的底层实现是红黑树，通过红黑树维护映射的有序性。由于要维护映射的有序性，因此 TreeMap 的各项操作的平均效率低于 HashMap，但是 TreeMap 可以按照顺序获得键值对。</p>
<p>Set 接口的定义和常用方法<br>
Set 接口存储一组互不相同的元素，一个集合中不存在两个相等的元素。</p>
<p>Set 接口继承了 Collection 接口，没有引入新的方法或常量，只是规定其实例不能包含相等的元素。</p>
<h2 id="Set-接口的实现类">Set 接口的实现类</h2>
<h3 id="HashSet">HashSet</h3>
<p>HashSet 类是散列集合，其<strong>底层实现基于 HashMap</strong>，就是 HashMap 套了个外壳，构造方法里创建的就是 HashMap 对象。</p>
<p>它把你要存的值当做 <code>HashMap</code>的 key，而 value 值是一个 <code>final</code>的<code>Object</code>对象，只起一个占位作用。而<code>HashMap</code>本身就不允许重复键，正好被<code>HashSet</code>拿来即用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>        ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br></code></pre></td></tr></table></figure>
<p>首先通过 hash 算法算出的值必须相等，算出的结果是 int，所以可以用 == 符号判断。并且待插入的 key == 当前索引已存在的 key，或者 待插入的 key.equals(当前索引已存在的key)，注意<code>==</code> 和 equals 是<strong>或</strong>的关系。== 符号意味着这是同一个对象， equals 用来确定两个对象内容相同。</p>
<p>根据<strong>散列约定，如果两个对象相同，它们的散列码一定相同</strong>，因此如果在子类中重写了 <strong>equals</strong> 方法，必须在该子类中重写 <strong>hashCode</strong> 方法，以保证两个相等的对象对应的散列码是相同的。</p>
<h3 id="TreeSet">TreeSet</h3>
<p>TreeSet 类是有序集合，其<strong>底层实现基于 TreeMap</strong>。和 TreeMap 相似，TreeSet 可以使用 Comparable 接口或 Comparator 接口对元素排序。</p>
<h3 id="LinkedHashSet">LinkedHashSet</h3>
<p>LinkedHashSet 就是套壳儿 LinkedHashMap</p>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>sleep 和 wait</title>
    <url>/2020/10/02/sleep-%E5%92%8C-wait/</url>
    <content><![CDATA[<h1>sleep 和 wait 的区别</h1>
<p><strong>sleep()是Thread的静态本地方法</strong>，<strong>wait()是Object的成员方法</strong>，二者是有本质区别。</p>
<p><strong>相同点</strong>： 一旦执行，都可以使得<strong>当前的线程进入等待状态</strong>。</p>
<p><strong>不同点</strong>：</p>
<ol>
<li>声明的位置不同，sleep()声明在Thread 类，wait()声明在Object 类；</li>
<li>sleep函数必须指定睡眠时间，wait可以指定也可以不指定；</li>
<li>sleep() 会让当前正在运行的、占用CPU时间片的线程<strong>挂起指定时间</strong>，休眠时间到自动苏醒进入可运行状态；wait() 方法用来<strong>线程间通信</strong>，如果设置了时间，就等待指定时间；如果不设置，则该对象在其它线程被调用 notify() / notifyAll() 方法后进入可运行状态，才有机会竞争获取对象锁。</li>
<li>适用场景不同，sleep()可以在任何需要的场景下调用，wait()必须在<strong>同步代码块</strong>中或者<strong>同步方法中的监视器</strong>中。</li>
<li>如果两方法都是使用在同步代码块或同步方法中，<strong>sleep()不会释放锁</strong>，wait()会释放锁，并进入线程等待池。</li>
</ol>
<p>sleep()线程<strong>控制自身流程</strong>，让当前线程休眠，不涉及对象类，也不需要获取对象锁，所以是 <strong>Thread</strong> 的方法。wait()用来<strong>线程间通信</strong>，使拥有该对象锁的线程等待直到指定时间或notify()，需要获得对象锁，所以是 <strong>Object</strong> 的方法。</p>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>git基础与实操</title>
    <url>/2022/03/17/git%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%AE%9E%E6%93%8D/</url>
    <content><![CDATA[<h1></h1>
<h2 id="起步">起步</h2>
<h3 id="历史">历史</h3>
<p>diff 和 patch<br>
-&gt; 本地 RCS<br>
-&gt; 集中式 CVS(Concurrent Version System) &amp; SVN(Subversion)<br>
-&gt; 分布式 git</p>
<p>git 是分布式版本控制系统，记录快照而不是累积的差异。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xianyuerrr/PicGo/img/Roaming/Typora/typora-user-images/image-20220317164242113.png" alt="image-20220317164242113"></p>
<h3 id="前置概念">前置概念</h3>
<p><img src="https://cdn.jsdelivr.net/gh/xianyuerrr/PicGo/img/Roaming/Typora/typora-user-images/image-20220317183339003.png" alt="image-20220317183339003"></p>
<h2 id="安装">安装</h2>
<p>基本命令</p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>Default</tag>
      </tags>
  </entry>
  <entry>
    <title>heapq 堆队列</title>
    <url>/2020/04/14/heapq-%E5%A0%86%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1>Python 堆队列 – heapq</h1>
<h2 id="介绍">介绍</h2>
<p>这个模块提供了堆队列算法的实现，也称为<strong>优先队列算法</strong>。</p>
<p>附上<a href="https://docs.python.org/zh-cn/3/library/heapq.html">Python3文档</a>。</p>
<p><strong>heapq</strong>是一个二叉树，它的每个父节点的值都只会小于或等于所有孩子节点（的值）。 它使用了数组来实现：从零开始计数，对于所有的 <em>k</em> ，都有 <code>heap[k] &lt;= heap[2*k+1]</code> 和 <code>heap[k] &lt;= heap[2*k+2]</code>。 为了便于比较，不存在的元素被认为是无限大。 堆最有趣的特性在于最小的元素总是在根结点：<code>heap[0]</code>。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>使用了<strong>从零开始</strong>的索引</li>
<li>堆为<strong>最小堆</strong></li>
</ul>
<h2 id="常用函数">常用函数</h2>
<ul>
<li><code>heappush(heap, item)</code>：保持堆的不变性。</li>
<li><code>heappop(heap)</code>：弹出并返回 <strong>heap</strong> 中最小的元素，保持堆的不变性。</li>
<li><code>heappushpop(heap, item)</code>：将 <strong>item</strong> 放入堆中，然后弹出并返回 <strong>heap</strong> 的最小元素，虽然先调用 <a href="https://docs.python.org/zh-cn/3/library/heapq.html#heapq.heappush"><code>heappush()</code></a> 再调用 <a href="https://docs.python.org/zh-cn/3/library/heapq.html#heapq.heappop"><code>heappop()</code></a> 也可以，但是这个更快。</li>
<li><code>heapify(x)</code>：将 <strong>list</strong> x 转换成堆，原地，线性时间</li>
<li><code>heapreplace(heap, item)</code>：弹出并返回 <strong>heap</strong> 中最小的一项，同时推入新的 <strong>item</strong>。比 <a href="https://docs.python.org/zh-cn/3/library/heapq.html#heapq.heappop"><code>heappop()</code></a> 加 <a href="https://docs.python.org/zh-cn/3/library/heapq.html#heapq.heappush"><code>heappush()</code></a> 更高效。</li>
</ul>
<h2 id="三个基于堆的通用功能函数">三个基于堆的通用功能函数</h2>
<ul>
<li>
<p><code>merge(*iterables, key=None, reverse=False)</code>：将多个已排序的输入合并为一个已排序的输出。类似于 <code>sorted(itertools.chain(*iterables))</code> 但返回一个可迭代对象，不会一次性地将数据全部放入内存，并假定每个输入流都是已排序的（从小到大）。</p>
<p>具有两个可选参数，它们都必须指定为关键字参数。</p>
<p><em>key</em> 指定带有单个参数的 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-key-function">key function</a>，用于从每个输入元素中提取比较键。 默认值为 <code>None</code> (直接比较元素)。</p>
<p><em>reverse</em> 为一个布尔值。 如果设为 <code>True</code>，则输入元素将按比较结果逆序进行合并。</p>
</li>
<li>
<p><code>nlargest</code>(<em>n</em>, <em>iterable</em>, <em>key=None</em>)<a href="https://docs.python.org/zh-cn/3/library/heapq.html#heapq.nlargest">¶</a></p>
<p>从 <em>iterable</em> 所定义的数据集中返回前 <em>n</em> 个最大元素组成的列表。 如果提供了 <em>key</em> 则其应指定一个单参数的函数，用于从 <em>iterable</em> 的每个元素中提取比较键 (例如 <code>key=str.lower</code>)。 等价于: <code>sorted(iterable, key=key, reverse=True)[:n]</code>。</p>
</li>
<li>
<p><code>nsmallest</code>(<em>n</em>, <em>iterable</em>, <em>key=None</em>)</p>
<p>从 <em>iterable</em> 所定义的数据集中返回前 <em>n</em> 个最小元素组成的列表。 如果提供了 <em>key</em> 则其应指定一个单参数的函数，用于从 <em>iterable</em> 的每个元素中提取比较键 (例如 <code>key=str.lower</code>)。 等价于: <code>sorted(iterable, key=key)[:n]</code>。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Python</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized 和 volatile</title>
    <url>/2021/08/22/synchronized-%E5%92%8C-volatile/</url>
    <content><![CDATA[<h1>synchronized 和 volatile</h1>
<p>关键字 synchronized 和 volatile 是多线程中经常用到的两个关键字。</p>
<h2 id="关键字-synchronized">关键字 synchronized</h2>
<p>关键字 synchronized 解决的是多个线程之间访问资源的同步性，该关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p>
<p>关键字 synchronized 最主要的三种使用方式是：修饰实例方法、修饰静态方法、修饰代码块。</p>
<p>修饰实例方法：给当前对象实例加锁，进入同步代码之前需要获得当前对象实例的锁。</p>
<p>修饰静态方法：给当前类加锁，进入同步代码之前需要获得当前类的锁。</p>
<p>修饰代码块：指定加锁对象，给指定对象加锁，进入同步代码块之前需要获得指定对象的锁。</p>
<h2 id="关键字-volatile">关键字 volatile</h2>
<p>关键字 volatile 解决的是变量在多个线程之间的可见性，该关键字修饰的变量会直接在主内存中进行读写操作，保证了变量的可见性。</p>
<p>除了保证变量的可见性以外，关键字 volatile 还有一个作用是确保代码的执行顺序不变。为了提高执行程序时的性能，编译器和处理器会对指令进行重排序优化，因此代码的执行顺序和编写代码的顺序可能不一致。添加关键字 volatile 可以禁止指令进行重排序优化。</p>
<p>只有当一个变量满足以下两个条件时，才能使用关键字 volatile。</p>
<p>对变量的写入操作不依赖变量的当前值，或者能确保只有单个线程更新变量的值。</p>
<p>该变量没有包含在具有其他变量的不变式中。</p>
<h2 id="关键字-synchronized-和-volatile-的区别">关键字 synchronized 和 volatile 的区别</h2>
<ol>
<li>
<p>关键字 volatile 是线程同步的轻量级实现，不需要加锁，因此性能优于关键字 synchronized。</p>
</li>
<li>
<p>关键字 synchronized 可以修饰方法和代码块，关键字 volatile 只能修饰变量。</p>
</li>
<li>
<p>关键字 synchronized 可能发生阻塞，关键字 volatile 不会发生阻塞。</p>
</li>
<li>
<p>关键字 synchronized 可以保证数据的可见性和原子性，关键字 volatile 只能保证数据的可见性，不能保证数据的原子性。</p>
</li>
<li>
<p>关键字 synchronized 解决的是多个线程之间访问资源的同步性，关键字 volatile 解决的是变量在多个线程之间的可见性。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>一维区间命中计数</title>
    <url>/2022/04/25/%E4%B8%80%E7%BB%B4%E5%8C%BA%E9%97%B4%E5%91%BD%E4%B8%AD%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<h1>一维区间命中计数</h1>
<p>问题描述为：多个区间，统计 target 在多少区间内。</p>
<p>e.g. <a href="https://leetcode-cn.com/problems/number-of-flowers-in-full-bloom/">力扣 6044. 花期内花的数目</a></p>
<p>给你一个下标从 <img src="https://math.now.sh?inline=0" style="display:inline-block;margin: 0;"/> 开始的二维整数数组 <img src="https://math.now.sh?inline=flowers" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=flowers%5Bi%5D%20%3D%20%5Bstarti%2C%20endi%5D" style="display:inline-block;margin: 0;"/> 表示第 i 朵花的 花期 从 <img src="https://math.now.sh?inline=starti" style="display:inline-block;margin: 0;"/> 到 <img src="https://math.now.sh?inline=endi" style="display:inline-block;margin: 0;"/> （都包含）。同时给你一个下标从 <img src="https://math.now.sh?inline=0" style="display:inline-block;margin: 0;"/> 开始大小为 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 的整数数组 <img src="https://math.now.sh?inline=persons" style="display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=persons%5Bi%5D" style="display:inline-block;margin: 0;"/> 是第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 个人来看花的时间。</p>
<p>请你返回一个大小为 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 的整数数组 <img src="https://math.now.sh?inline=answer" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=answer%5Bi%5D" style="display:inline-block;margin: 0;"/> 是第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 个人到达时在花期内花的数目 。</p>
<h2 id="方法一">方法一</h2>
<p>按时间遍历 + 小根堆 + 延迟删除</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> heapq <span class="hljs-keyword">import</span> *<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fullBloomFlowers</span>(<span class="hljs-params">self, flowers: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], persons: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:</span><br>        m = <span class="hljs-built_in">len</span>(flowers)<br>        n = <span class="hljs-built_in">len</span>(persons)<br>        res = [<span class="hljs-number">0</span>] * n<br><br>        <span class="hljs-comment"># 把花期表按照花期开始时间排序</span><br>        flowers.sort()<br>        flower_idx = <span class="hljs-number">0</span><br>        q = []<br>        size = <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">for</span> cur, idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">zip</span>(persons, <span class="hljs-built_in">range</span>(n)), key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">0</span>]):<br>            <span class="hljs-comment"># 把花期已经结束的弹出堆</span><br>            <span class="hljs-keyword">while</span> size &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> q[<span class="hljs-number">0</span>] &lt; cur:<br>                heappop(q)<br>                size -= <span class="hljs-number">1</span><br>            <span class="hljs-comment"># 将花期应该在 cur 前（包括 cur）已经开始，否则 cur 时刻此花不可能处于花期</span><br>            <span class="hljs-keyword">while</span> flower_idx &lt; m <span class="hljs-keyword">and</span> flowers[flower_idx][<span class="hljs-number">0</span>] &lt;= cur:<br>                <span class="hljs-comment"># 花期在 cur 还未结束，若花期在 cur 已经结束，那么就不可能在 cur 以及之后的时刻处于花期</span><br>                <span class="hljs-keyword">if</span> flowers[flower_idx][<span class="hljs-number">1</span>] &gt;= cur:<br>                    heappush(q, flowers[flower_idx][<span class="hljs-number">1</span>])<br>                    size += <span class="hljs-number">1</span><br>                flower_idx += <span class="hljs-number">1</span><br>            <span class="hljs-comment"># print(cur, q)</span><br>            res[idx] = size<br>        <span class="hljs-keyword">return</span> res<br><br></code></pre></td></tr></table></figure>
<h2 id="方法二">方法二</h2>
<p>问题转换：正在开的花的个数 = 已开放的花的个数 - 已凋谢的花的个数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> heapq <span class="hljs-keyword">import</span> *<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fullBloomFlowers</span>(<span class="hljs-params">self, flowers: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], persons: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:</span><br>        m = <span class="hljs-built_in">len</span>(flowers)<br>        n = <span class="hljs-built_in">len</span>(persons)<br>        res = [<span class="hljs-number">0</span>] * n<br><br>        <span class="hljs-comment"># 分别统计 cur 时刻已经开放的花的数目 open_cnt、已经凋谢的花 close_cnt</span><br>        <span class="hljs-built_in">open</span> = [x <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> flowers]<br>        close = [y <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> flowers]<br>        <span class="hljs-built_in">open</span>.sort(), close.sort()<br>        open_cnt = close_cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> cur, idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">zip</span>(persons, <span class="hljs-built_in">range</span>(n)), key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">0</span>]):<br>            <span class="hljs-keyword">while</span> open_cnt &lt; n <span class="hljs-keyword">and</span> <span class="hljs-built_in">open</span>[open_cnt] &lt;= cur:<br>                open_cnt += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> close_cnt &lt; n <span class="hljs-keyword">and</span> close[close_cnt] &lt; cur:<br>                close_cnt += <span class="hljs-number">1</span><br>            res[idx] = open_cnt - close_cnt<br>        <span class="hljs-keyword">return</span> res<br><br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>字节后端开发</title>
    <url>/2021/10/09/%E5%AD%97%E8%8A%82%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91-1/</url>
    <content><![CDATA[<h1>字节电商后端</h1>
<p>流程介绍</p>
<p>自我介绍</p>
<h3 id="Java">Java</h3>
<p>HashMap 和 HashTable</p>
<p>Java concurrentmap 的size如何获取</p>
<p>Java除了 synch 还有什么锁</p>
<h3 id="数据库">数据库</h3>
<p>幻读怎么解决的</p>
<h3 id="代码">代码</h3>
<p>数据库两题</p>
<p>算法一题</p>
<p>判断二叉搜索树，挺简单，不过测试时建树建出问题了</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>字节</tag>
      </tags>
  </entry>
  <entry>
    <title>刚开始接触Python时的一些问题</title>
    <url>/2019/10/06/%E5%88%9A%E5%BC%80%E5%A7%8B%E6%8E%A5%E8%A7%A6Python%E6%97%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1>刚开始接触Python时的一些问题</h1>
<h2 id="新版本不是最好的">新版本不是最好的</h2>
<p>  查看你的Python版本，最好不要安装太老的版本，同时，也不要以为最新版就是最好的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">python --version<br><span class="hljs-comment"># 或者</span><br>python -V<br></code></pre></td></tr></table></figure>
<p>  尽量不要使用最新版的Python，在使用的过程中可能会遇到一些奇怪的问题，毕竟第三方库的数量极其庞大，短时间内不能保证所有库都适配。由于版本较新，遇到问题了在网上也不太容易找到解决办法。</p>
<h2 id="运行项目">运行项目</h2>
<p>  按住Shift点击右键会出现如下界面，点击**“在此处打开PowerShell窗口”**可以直接在当前目录打开PowerShell窗口。</p>
<img src="https://img-blog.csdnimg.cn/20201109214244759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODc0ODM0,size_16,color_FFFFFF,t_70#pic_center"  height="30%" width="30%" alt="截图" align=center/>
<p>  可以使用以下命令运行项目</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">python -m Project_name<br><span class="hljs-comment"># Project_name是想要运行的项目名 </span><br></code></pre></td></tr></table></figure>
<p>  截图：</p>
<img src="https://img-blog.csdnimg.cn/20201109214709987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODc0ODM0,size_16,color_FFFFFF,t_70#pic_center"  height="80%" width="80%" alt="截图" align=center />
<p>  但是对于很多项目，如果是新装的Python，在运行使用了第三方库的项目时大多都会出现以下错误:</p>
<ol>
<li>找不到第三方库</li>
</ol>
<img src="https://img-blog.csdnimg.cn/20201109214948851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODc0ODM0,size_16,color_FFFFFF,t_70#pic_center"  height="80%" width="80%" alt="截图" align=center />
<p>  这种情况一般安装全部此项目所使用的第三方库之后就会消失，可以使用以下命令安装：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">pip install package<br><span class="hljs-comment"># package是你当前需要安装的第三方库的名字</span><br></code></pre></td></tr></table></figure>
<ol start="2">
<li>numpy出错（这代表着一类问题，有些类库出问题时可以使用类似方法解决）</li>
</ol>
<img src="https://img-blog.csdnimg.cn/20201109215440534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODc0ODM0,size_16,color_FFFFFF,t_70#pic_center"  height="100%" width="100%" alt="截图" align=center />
<p>  上图显示是numpy出问题了，使用以下命令查看numpy版本，是1.19.4版本，尝试降低版本再次尝试。(新版本不一定最好)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">pip show numpy<br></code></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/20201109215440453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODc0ODM0,size_16,color_FFFFFF,t_70#pic_center"  height="100%" width="100%" alt="截图" align=center />
<p>  卸载numpy1.19.4版本，安装numpy1.19.3版本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">pip uninstall numpy<br>pip install numpy==<span class="hljs-number">1.19</span><span class="hljs-number">.3</span> <span class="hljs-comment"># 这种方式可以指定安装库的版本</span><br></code></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/20201109215440461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODc0ODM0,size_16,color_FFFFFF,t_70#pic_center"  height="100%" width="100%" alt="截图" align=center />
<h2 id="第三方库下载慢">第三方库下载慢</h2>
<p>  Python安装库默认是从官网下载的，对于部分人来说，从官网下载实在是过于缓慢。这个时候，切换一个源就可以使下载速度提升一个档次。可以使用清华大学的开源镜像站。</p>
<p>  （1）想要临时使用镜像站</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package<br>// 注意：some-package指的是想要安装的库，使用时需要进行更改<br></code></pre></td></tr></table></figure>
<p>  （2）设为默认</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pip -U<br>pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple<br></code></pre></td></tr></table></figure>
<p>  之后再进行第三方库的下载安装时就默认从镜像站进行下载了。</p>
<p>  换源命令执行成功的截图：</p>
<img src="https://img-blog.csdnimg.cn/20201109220010780.png#pic_center"  height="100%" width="100%" alt="截图" align=center />
<h2 id="路径问题（找不到文件）">路径问题（找不到文件）</h2>
<p>  项目路径问题：</p>
<img src="https://img-blog.csdnimg.cn/20201109215440533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODc0ODM0,size_16,color_FFFFFF,t_70#pic_center"  height="100%" width="100%" alt="截图" align=center />
<p>  上图的错误是一个<strong>FileNotFoundError</strong>，说明无法找到那个<strong>txt</strong>文本，但是这个文件确实是在目录下的，如下：</p>
<img src="https://img-blog.csdnimg.cn/20201109215440505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODc0ODM0,size_16,color_FFFFFF,t_70#pic_center"  height="100%" width="100%" alt="截图" align=center />
<p>  根据报错信息，我们可以知道是<strong>Logistic_classify.py</strong>的<strong>line 27</strong>出错了，我们可以在Logistic_classify.py头部添加以下代码来修正运行时的目录，使其能够找到<strong>horseColicTraining.txt</strong>文件（不止这一种方式可以解决此问题）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br>os.chdir(os.path.dirname(__file__))<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>内存泄露与内存溢出</title>
    <url>/2021/09/01/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/</url>
    <content><![CDATA[<h3 id="内存泄露与内存溢出">内存泄露与内存溢出</h3>
<p><strong>内存泄漏</strong>（Memory Leak）是指内存用完没有被释放，即不再被引用的对象没有被 jvm 回收。大量的内存泄漏就会导致OOM，也就是内存溢出。</p>
<p><strong>内存溢出</strong>（OOM），指需要的内存空间<strong>大于</strong>系统分配的内存空间。</p>
<p>内存泄露分类：</p>
<ol>
<li>常发性泄露：每次执行都导致一块内存泄漏</li>
<li>偶发性泄露：特定环境或操作过程下才会发生</li>
<li>一次性泄露：只会被执行一次</li>
<li>隐式泄露：运行时不停分配内存，但是直到结束时才释放。严格来说并不能算是泄露，但由于<strong>服务器程序</strong>运行较久，不及时释放内存也可能导致耗尽内存。</li>
</ol>
<p><strong>内存泄漏最终会导致内存溢出！！！</strong></p>
<p>内存泄漏本身不会产生什么危害，一般的用户根本感觉不到内存泄漏的存在。真正有危害的是<strong>内存泄漏的堆积</strong>，这会最终消耗尽系统所有的内存。</p>
<p>从这个角度来说，一次性内存泄漏并没有什么危害，因为它不会堆积，而隐式内存泄漏危害性则非常大，因为较之于常发性和偶发性内存泄漏它<strong>更难被检测到</strong>。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>字节后端开发</title>
    <url>/2021/08/21/%E5%AD%97%E8%8A%82%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h2 id="一面">一面</h2>
<p>算法题</p>
<p>1、某游戏中，某套装需要5个不同的配件，某个副本每次通关会随机奖励其中的一件，凑齐此套装需要通关此副本的平均次数是多少？</p>
<p>2、1的个数</p>
<p>一、输入一个正整数int n，求其转为2进制数后，其中1的个数。如：</p>
<p>0:  0000 -&gt; 0</p>
<p>1:  0001 -&gt; 1</p>
<p>2:  0010 -&gt; 1</p>
<p>3:  0011 -&gt; 2</p>
<p>4:  0100 -&gt; 1</p>
<p>5:  0101 -&gt; 2</p>
<p>6:  0110 -&gt; 2</p>
<p>7:  0111 -&gt; 3</p>
<p>8:  1000 -&gt; 1</p>
<p>9:  1001 -&gt; 2</p>
<p>10: 1010 -&gt; 2</p>
<p>二、输入一个正整数int n，求 区间[1, n]中，所有整数转为2进制数后，1的个数之和。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>字节</tag>
      </tags>
  </entry>
  <entry>
    <title>字节大数据开发</title>
    <url>/2021/08/06/%E5%AD%97%E8%8A%82%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1>字节跳动大数据开发</h1>
<h2 id="一面">一面</h2>
<p>面试用的牛客网，一个胖胖的很可爱的大哥</p>
<p><strong>自我介绍</strong></p>
<p>介绍的很烂，逻辑不够清晰，不流畅，不让介绍我优秀的室友</p>
<p>学习能力强</p>
<p>简单说了两句</p>
<p>问了专业（信息与计算科学）是不是普通计算机专业。</p>
<p>是不是明年6月份毕业</p>
<p>1、学过数据库吗？</p>
<p><strong>数据库系统</strong>与<strong>文件系统</strong>的区别，在使用上有什么区别，</p>
<p>没想过 ，答的很差</p>
<p>2、数据库事务是什么，什么是数据库索引。假如我们设计一个表，有20个字段，哪些字段需要加索引，讲一下加索引的方法。</p>
<p>3、学过计算机网络吗？讲一下<strong>TCP</strong>与<strong>UDP</strong>的区别。</p>
<p>TCP在建立连接后，它在传输的时候有什么特点，比如可靠什么的。</p>
<p>三次握手、四次挥手、拥塞控制、流量控制这些主要是为了实现什么目标。</p>
<p>哪些场景需要用UDP协议。</p>
<p>像直播，如果它的数据包的顺序错了之后对直播的画面有什么影响。</p>
<p>4、数据结构学过吗？</p>
<p>说一下二叉树与平衡二叉树的区别。</p>
<p><strong>B+树</strong>是什么？与平衡二叉树有什么区别。<strong>下去再看一下这块儿</strong></p>
<p><strong>时刻：12分钟</strong></p>
<p>5、做两道题目</p>
<p>题目1：给一个递增数组，实现一个<strong>二分查找</strong>。查不到就返回-1。如果数组内容可重复，返回区间，查不到返回 [-1, -1]</p>
<p>题目2：给定一个字符串，判断是否是<strong>合法的IPv4地址</strong>，使用了Python的库，后来经过提示，加上了对于<strong>前导0</strong>的考虑</p>
<p><strong>时刻：37分钟</strong></p>
<p>题目三：sql查询，查询每个部门工资最高的员工的ID。sql一年没用过了，我太难了，在面试官的提醒下磕磕绊绊写完了。<strong>下去再练练</strong></p>
<p><strong>时刻：49分钟</strong></p>
<p>6、总结</p>
<p>专业基础知识没有太认真看，下去再看一下，代码写的还可以。</p>
<p>7、反问</p>
<p>如何加深认识</p>
<p>把相关专业概念、理论知识记熟</p>
<p>在实践过程中，多实践，积累之后再去回顾这些概念，实践之后理解会更深一些</p>
<p>需要把思考和实践做一个迭代</p>
<p>技术的理论、目的，为什么使用这种方法，这种方法的利弊</p>
<p>概念是为各种实践服务的，而不是凭空出现的。</p>
<p>可以找一些项目做</p>
<p>8、问我下半年还有课吗，可以实习的时间</p>
<p>10月到3月会闲一些</p>
<p><strong>时刻：55分钟</strong></p>
<h2 id="二面">二面</h2>
<p><strong>一个半小时</strong></p>
<p>面试用的牛客网，还是上次的房间，一个戴着戒指的大哥。</p>
<p><strong>自我介绍</strong></p>
<p>平平无奇的自我介绍。可能还是面试经验少，紧张，语速控制不住，不过好像不是很关键</p>
<p><strong>时刻：2分钟</strong></p>
<p>也问了专业（信息与计算科学）是不是普通计算机专业。</p>
<p>问了平常用什么语言，会写SQL吗，一开始我听错了，听成了C扣…</p>
<p><strong>时刻：5分钟</strong></p>
<p>直接开始写算法题</p>
<p>1、题目1：给一个非空数组，返回数目最多的元素，如果有多个数目最多的元素，返回最短的子串长度（第一次出现到最后一次出现）。</p>
<p>还贴心的对题目进行了解释</p>
<p>思路：1） 遍历一次，进行计数，并且记录出现最多的次数； 2）把出现次数为最多次数的元素存进列表；3）寻找这些元素第一次出现的位置以及最后一次出现的位置；4）找到子串最短的元素；5）输出</p>
<p>第一次理解还是有些偏差，把那个元素输出了，<strong>题目只是要长度</strong></p>
<p>写完让讲解代码思路，分析复杂度，然后问有没有更优的写法</p>
<p>第一次写的是 O（N*k），k 是出现次数为最多次的元素的数目。写的时候就发现可以把找首次出现与末次出现的寻找放到计数步骤，由于字典的查找为O（1）的，所以复杂度就降到了O（N）</p>
<p>面试的时候口齿不清，表达不明白，还好面试官厉害，理解了我说的意思【流汗黄豆】</p>
<p><strong>时刻：26分钟</strong></p>
<p>2、题目2：给定一个非空数组，求下标 i，j 之间的区间和，需要进行 m 次查找</p>
<p>看到题目我第一想法是遍历累加，也就 O（N）的复杂度</p>
<p>可是如果进行 m 次的话，每次加一次太浪费时间了，后来在纸上演算，发现可以先计算部分和，然后再相减，进一步想到了前缀和。</p>
<p>只用计算一次前缀和，在此基础上的 m 次操作每次都是 O（1）的了，总体复杂度是 O（N+1）</p>
<p><strong>时刻：35分钟</strong></p>
<p>3、题目3：给定一个数组，求所有两个数字和等于 target 的所有的数字对。</p>
<p>首先是O（N2）的暴力</p>
<p>O（NLogN）的排序查找，有序也为O（NLogN）</p>
<p>排序+双指针，O（NLogN），有序为 O（N）</p>
<p>哈希表，O（N）</p>
<p><strong>时刻：41分钟</strong></p>
<p>4、题目4：假设有一个很大的日志文件，每行存一个IP地址，每次访问都存一个IP地址，找出访问量最多的10个IP。</p>
<p>分批</p>
<p>找出每批最多的10个IP，刚开始没想起来堆，只想使用快排，后来经过面试官的多次提醒，想到了使用最小堆存最大的10个数，</p>
<p>但可能是局部最大</p>
<p><strong>没想到</strong>可以<strong>把哈希表存在外存里</strong>，这样就能求出来了。面试官看我实在不知道数据库、大数据之类的处理方式，把他存到外存，就告诉我了</p>
<p><strong>时刻：55分钟</strong></p>
<p>5、数据库引擎了解吗？（我完全不了解…）</p>
<p>6、想问索引，但是我了解不多。</p>
<p>7、索引优化、SQL优化（也不太了解）</p>
<p>8、HTTP状态码</p>
<p>​	200、301、302、404、502、503</p>
<p>由于提到了301、302的重定向，问有什么方式能够配置代理（不会配置，说了自己的理解）他问我用过<strong>nginx</strong>吗，我听成了Linux，然鹅Linux我也用的不多。</p>
<p>9、喜闻乐见的前端要访问后端，然后前端的页面一直刷不出来，是哪里出了问题，如何排查，有什么思路和方法。</p>
<p>虽然我不知道，但是按照自己的想法说了，然鹅我并不知道如何进行排查。</p>
<p>面试官提醒说结合刚刚问的HTTP内容，然后我就立马说（重定向，他马上就说了不一定， 哈哈），然后就想到可能是代理服务器的问题。</p>
<p>之后面试官看看我说不出来了，就给我进行了讲解。</p>
<p>开发过程中，后端的问题可能会多一点，但在一个线上的项目，大部分的问题基本上都是网络环境出现了问题，还有DNS有问题 。</p>
<p>要把它当作一个线上的应用来看待，页面刷不出来，大部分是网络有问题，或者是我们整个机房挂了，或者是后端扛不住了。</p>
<p><strong>时刻：67分钟</strong></p>
<p>10、有学过操作系统是吧？学的是什么操作系统？Linux还是别的什么</p>
<p>我：……没有根据具体系统讲解</p>
<p>你们的原理肯定也会落实到某些系统上，你们不会上机或者去做一些其他的？</p>
<p>我：真没有…，尬住了。我说我结合课本、博客在Windows系统上进行过理解</p>
<p>为什么没有用Linux系统去进行尝试呢？</p>
<p>后来就给我讲了一些他的经验，你是做这个行业的，还是应该去用的</p>
<p><strong>时刻：71分钟</strong></p>
<p>舍友回来了…</p>
<p>11、在学校或者说平常，做过什么偏应用类的东西，分析也好、数学也好什么的都行。</p>
<p>说了写过爬虫，所以还能记得与网页有关的一些都行。之后详细说了之前对疫情期间的一次建模分析。</p>
<p>现在去回顾这件事情，你觉得有哪些地方是可以做的更好的？</p>
<p>我：基本上每部分我都觉得能做的更好、更合理</p>
<p>有没有看到行业上是怎么做这件事的？</p>
<p>我看过但不记得了，只能说没看过很具体的分析，更多是参照了以往，特别是非典时期的文章成果</p>
<p><strong>时刻：81分钟</strong></p>
<p>12、目前的计划打算</p>
<p><strong>时刻：84分钟</strong></p>
<p>13、反问</p>
<p>咱们这边的话做的最多的业务是关于什么的</p>
<p>如果拿到offer了，想要提前去实习以便提前掌握正式工作需要的知识与技术，那么应该主要去学习哪些内容，实习之后最大的收获可能是哪些方面的</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>字节</tag>
      </tags>
  </entry>
  <entry>
    <title>异或性质</title>
    <url>/2020/01/30/%E5%BC%82%E6%88%96%E6%80%A7%E8%B4%A8/</url>
    <content><![CDATA[<h1>异或</h1>
<p>异或运算的性质：</p>
<p><strong>1.</strong> 交换律：A ^ B = B ^ A;</p>
<p><strong>2.</strong> 结合律：A ^ (B ^ C) = (A ^ B) ^ C;</p>
<p><strong>3.</strong> 恒等律：X ^ 0 = X;</p>
<p><strong>4.</strong> 归零律：X ^ X = 0;</p>
<p><strong>5.</strong> 自反：A ^ B ^ B = A ^ 0 = A;</p>
<p><strong>6.</strong> 对于任意的 X： X ^ (-1) = ~X；</p>
<p><strong>7.</strong> 如果 A ^ B = C 成立，那么 A ^ B = C，B ^ C = A；</p>
<p><strong>8.</strong><img src="https://math.now.sh?inline=%5Cforall%20i%20%5Cin%20Z" style="display:inline-block;margin: 0;"/>，有 <img src="https://math.now.sh?inline=4i%20%5Coplus%20%284i%2B1%29%20%5Coplus%20(4i%2B2)%20%5Coplus%20(4i%2B3)%20%3D%200" style="display:inline-block;margin: 0;"/>。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>异或</tag>
      </tags>
  </entry>
  <entry>
    <title>布隆过滤器</title>
    <url>/2021/09/14/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<h1>布隆过滤器</h1>
<img src="https://raw.githubusercontent.com/xianyuerrr/PicGo/main/img/20210914175752.jpeg" alt="kf0ylib9os" style="zoom:67%;" />
<ol>
<li>首先需要k个hash函数，每个函数可以把key散列成为1个整数；</li>
<li>初始化时，需要一个长度为n比特的数组，每个比特位初始化为0；</li>
<li>某个key加入集合时，用<strong>k个hash函数</strong>计算出k个散列值，并把数组中对应的比特位置为1；</li>
<li>判断某个key是否在集合时，用k个hash函数计算出k个散列值，并查询数组中对应的比特位，如果所有的比特位都是1，认为在集合中；</li>
</ol>
<p><strong>优点：</strong></p>
<ol>
<li>空间效率和查询时间都远超一般的算法，布隆过滤器存储空间和插入 / 查询时间都是常数O(k)。</li>
<li>散列函数相互之间没有关系，方便由硬件并行实现</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>随着存入的元素数量增加，误算率随之增加。但是如果元素数量太少，则使用散列表足矣。</li>
<li>一般情况下不能从布隆过滤器中删除元素。我们很容易想到把位数组变成整数数组，每插入一个元素相应的计数器加 1, 这样删除元素时将计数器减掉就可以了。然而要保证安全地删除元素并非如此简单。首先我们<strong>必须保证删除的元素的确在布隆过滤器里面</strong>。这一点单凭这个过滤器是无法保证的。</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>面试</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>对象相等的判断，== 和 equal</title>
    <url>/2020/11/20/%E5%AF%B9%E8%B1%A1%E7%9B%B8%E7%AD%89%E7%9A%84%E5%88%A4%E6%96%AD%EF%BC%8C-%E5%92%8C-equal/</url>
    <content><![CDATA[<h1>值相等与对象相同</h1>
<h2 id="Python">Python</h2>
<p>在<em><strong>python</strong></em>中，我们使用 <strong>==</strong> 来进行判断两个对象的值是否相等，使用<strong>is</strong>来判断两个对象是否是同一个对象。is 是种很特殊的语法，在其它的语言一般不会见到这样的用法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># int型比较</span><br>a = <span class="hljs-number">1</span><br>b = <span class="hljs-number">1</span><br><br><span class="hljs-built_in">print</span>(a == b)<br><span class="hljs-comment"># 结果为True</span><br><span class="hljs-built_in">print</span>(a <span class="hljs-keyword">is</span> b)<br><span class="hljs-comment"># 结果为True</span><br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># str型比较</span><br>str1 = <span class="hljs-string">&#x27;abc&#x27;</span><br>str2 = <span class="hljs-string">&#x27;abc&#x27;</span><br><br><span class="hljs-built_in">print</span>(str1 == str2)<br><span class="hljs-comment"># 结果为True</span><br><span class="hljs-built_in">print</span>(str1 <span class="hljs-keyword">is</span> str2)<br><span class="hljs-comment"># 结果为True</span><br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 自定类型比较</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">my_obj</span>:</span><br>4atr1 = <span class="hljs-number">0</span><br>4atr2 = <span class="hljs-number">1</span><br>4<br>obj1 = my_obj()<br>obj2 = my_obj()<br> <br><span class="hljs-built_in">print</span>(obj1 == obj2)<br><span class="hljs-comment"># 结果为False</span><br><span class="hljs-built_in">print</span>(obj1 <span class="hljs-keyword">is</span> obj2)<br><span class="hljs-comment"># 结果为False</span><br></code></pre></td></tr></table></figure>
<h2 id="Java">Java</h2>
<p>在<em><strong>java</strong></em>中，我们使用 <strong>==</strong> 来判断两个对象是否是同一个对象，而使用<strong>equals</strong>方法来判断两个对象的值是否相等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test03</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> b = <span class="hljs-number">1</span>;<br>        System.out.println(<span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-string">&quot; = &quot;</span> + <span class="hljs-string">&#x27;b&#x27;</span> + <span class="hljs-string">&quot;:&quot;</span> + (a == b));<br>        System.out.println(<span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-string">&quot;的地址：&quot;</span> + System.identityHashCode(a));<br>        System.out.println(<span class="hljs-string">&#x27;b&#x27;</span> + <span class="hljs-string">&quot;的地址：&quot;</span> + System.identityHashCode(b));<br><br>        String str1 = <span class="hljs-string">&quot;csdn&quot;</span>;<br>        String str2 = <span class="hljs-string">&quot;csdn&quot;</span>;<br>        <span class="hljs-comment">// str1 和 str2 在常量池中，只有一份，是同一个对象</span><br>        String str3 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;csdn&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;str1&quot;</span> + <span class="hljs-string">&quot;和&quot;</span> + <span class="hljs-string">&quot;str2&quot;</span> + <span class="hljs-string">&quot;是同一个对象：&quot;</span> + (str1 == str2));<br>        System.out.println(<span class="hljs-string">&quot;str1&quot;</span> + <span class="hljs-string">&quot; = &quot;</span> + <span class="hljs-string">&quot;str2&quot;</span> + <span class="hljs-string">&#x27;:&#x27;</span> + str1.equals(str2));<br>        System.out.println(<span class="hljs-string">&quot;str1&quot;</span> + <span class="hljs-string">&quot;和&quot;</span> + <span class="hljs-string">&quot;str3&quot;</span> + <span class="hljs-string">&quot;是同一个对象：&quot;</span> + (str1 == str3));<br>        System.out.println(<span class="hljs-string">&quot;str1&quot;</span> + <span class="hljs-string">&quot; = &quot;</span> + <span class="hljs-string">&quot;str3&quot;</span> + <span class="hljs-string">&#x27;:&#x27;</span> + str1.equals(str3));<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 输出结果如下：</span><br><span class="hljs-comment">// a = b:true</span><br><span class="hljs-comment">// a的地址：664223387</span><br><span class="hljs-comment">// b的地址：664223387</span><br><span class="hljs-comment">// str1和str2是同一个对象：true</span><br><span class="hljs-comment">// str1 = str2:true</span><br><span class="hljs-comment">// str1和str3是同一个对象：false</span><br><span class="hljs-comment">// str1 = str3:true</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>找回.py文件右键的Edit with IDLE选项</title>
    <url>/2020/03/26/%E6%89%BE%E5%9B%9E-py%E6%96%87%E4%BB%B6%E5%8F%B3%E9%94%AE%E7%9A%84Edit-with-IDLE%E9%80%89%E9%A1%B9/</url>
    <content><![CDATA[<h1>找回.py文件右键的Edit with IDLE选项</h1>
<p>  通常我们安装Python之后会在**.py<strong>文件的右键菜单中找到</strong>Edit with IDLE<strong>这个选项。今天突然发现右键的</strong>Edit with IDLE<strong>先是点击之后不能打开</strong>.py**文件了，后来干脆就直接没了。虽然平时用的比较少，但是这个IDLE还是很方便的，必须给弄回来。</p>
<p>  在一通搜索和尝试之后，只发现了修改注册表的方法有用，但是显得有些麻烦，后来发现可以编写一个**.reg**文件来完成这件事情。</p>
<p>  将下面内容保存到一个**.reg**文件中，注意修改最后一行中Python的安装路径。（注意：注册表中的路径用的是\\来表示\，别写错了）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Windows Registry Editor Version 5.00<br><br>[HKEY_CLASSES_ROOT\SystemFileAssociations\.py]<br><br>[HKEY_CLASSES_ROOT\SystemFileAssociations\.py\shell]<br><br>[HKEY_CLASSES_ROOT\SystemFileAssociations\.py\shell\editwithidle]<br>&quot;MUIVerb&quot;=&quot;&amp;Edit with IDLE&quot;<br>&quot;Subcommands&quot;=&quot;&quot;<br><br>[HKEY_CLASSES_ROOT\SystemFileAssociations\.py\shell\editwithidle\shell]<br><br>[HKEY_CLASSES_ROOT\SystemFileAssociations\.py\shell\editwithidle\shell\edit37]<br>&quot;MUIVerb&quot;=&quot;Edit with IDLE 3.7&quot;<br><br>[HKEY_CLASSES_ROOT\SystemFileAssociations\.py\shell\editwithidle\shell\edit37\command]<br>@=&quot;\&quot;D:\\python\\pythonw.exe\&quot; -m idlelib \&quot;%L\&quot; %*&quot;<br></code></pre></td></tr></table></figure>
<p>  注释版：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Windows Registry Editor Version 5.00<br><br>[HKEY_CLASSES_ROOT\SystemFileAssociations\.py]<br># 在“HKEY_CLASSES_ROOT\SystemFileAssociations”项下创建了一个名为“.py”的项<br><br>[HKEY_CLASSES_ROOT\SystemFileAssociations\.py\shell]<br># 在“.py”项下创建了一个名为“shell”的项<br><br>[HKEY_CLASSES_ROOT\SystemFileAssociations\.py\shell\editwithidle]<br>&quot;MUIVerb&quot;=&quot;&amp;Edit with IDLE&quot;<br>&quot;Subcommands&quot;=&quot;&quot;<br># 在“shell”项下创建了一个名为“editwithidle”的项。<br># 在“editwithidle”项中创建了：一个名为&quot;MUIVerb&quot;的字符串值，值为&quot;&amp;Edit with IDLE&quot;；一个名为&quot;Subcommands&quot;的空字符串值<br><br>[HKEY_CLASSES_ROOT\SystemFileAssociations\.py\shell\editwithidle\shell]<br># 在“editwithidle”项中创建了一个名为“shell”的项<br><br>[HKEY_CLASSES_ROOT\SystemFileAssociations\.py\shell\editwithidle\shell\edit37]<br>&quot;MUIVerb&quot;=&quot;Edit with IDLE 3.7&quot;<br># 在“shell”项下创建一个名为“edit37”的项<br># 在“edit37”项下创建一个名为&quot;MUIVerb&quot;，值为&quot;Edit with IDLE 3.7&quot; 的字符串值<br><br>[HKEY_CLASSES_ROOT\SystemFileAssociations\.py\shell\editwithidle\shell\edit37\command]<br>@=&quot;\&quot;D:\\python\\pythonw.exe\&quot; -m idlelib \&quot;%L\&quot; %*&quot;<br># 在“edit37”项创建一个名为“command”的项<br># 将“command”项中的默认值修改为“python安装路径\pythonw.exe\&quot; -m idlelib \&quot;%L\&quot; %*&quot;<br></code></pre></td></tr></table></figure>
<p>其中<strong>MUIVerb</strong>的值是用来控制显示内容的，可以按照自己的想法去改。</p>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>小米安卓开发</title>
    <url>/2021/09/30/%E5%B0%8F%E7%B1%B3%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1>小米 Android开发工程师（可接受java方向）</h1>
<h2 id="一面">一面</h2>
<p>9月15日</p>
<p>自我介绍</p>
<p>1、考研吗（公司喜欢不考的）</p>
<p>2、Java 是跨平台的吗，为什么</p>
<p>3、Java 的访问修饰符有哪些，有什么区别</p>
<p>4、this 与 super</p>
<p>5、两个对象相等如何判断，String 的 equals() 方法是判断值的吗</p>
<p>6、JVM 的内存结构（说的不好），堆是线程公有的吗？那栈呢</p>
<p>7、String、StringBuffer、StringBuilder 区别</p>
<p>8、说一下 final 关键字，修饰 基本类型与引用类型 时有什么区别</p>
<p>9、synchronized 和 volatile</p>
<p>10、对原子性和有序性的理解。n = n+1 是原子的吗？</p>
<p>11、说一下对线程池的理解</p>
<p>12、看过 HashMap 源码吗，讲一下 HashMap。（很多关于这个的帖子，主要就是扩容，看一看就理解了）</p>
<p>13、算法题，简单的递归</p>
<p>14、反问</p>
<h2 id="二面">二面</h2>
<p>9月29日</p>
<p>自我介绍</p>
<p>1、Java中有哪些IO模型</p>
<p>2、Java运行时数据区域有哪些，PC计数器是线程独有的吗（Java里是的，每个线程都有一个），元数据区</p>
<p>3、Java 双亲委派机制</p>
<p>这部分答的不是很好，换内容问了</p>
<p>4、进线程有什么区别</p>
<p>5、上下文切换都切换了什么东西</p>
<p>6、进程的调度算法，现代操作系统1s轮转多少次，磁盘调度算法</p>
<p>7、七层网络</p>
<p>8、操作系统一般使用哪些层</p>
<p>9、算法题，层序遍历的小变种</p>
<p>10、能接受开发安卓框架吗，是在底层和应用之间</p>
<p>11、反问</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>小米</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库拷问</title>
    <url>/2021/12/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8B%B7%E9%97%AE/</url>
    <content><![CDATA[<h1>做数据库的过程是对自己的灵魂拷问</h1>
<ol>
<li>这玩意怎么存下去呢？</li>
<li>存好了，怎么读比较快？</li>
<li>能不能方便地读，是不是支持个SQL比较好？</li>
<li>单线程来读很快了，并发怎么办？</li>
<li>并发搞定了，crash了咋搞？</li>
<li>crash recover搞定了，单机性能瓶颈了，怎么办？</li>
<li>搞成分布式了，一致性咋保证？</li>
<li>分布式一致性搞定了，多租户流量怎么调度？</li>
<li>多租户问题搞定了，用户想来跑OLAP query怎么办？</li>
</ol>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库面试常问知识点</title>
    <url>/2021/09/02/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h1>数据库</h1>
<h2 id="引擎">引擎</h2>
<p><img src="https://raw.githubusercontent.com/xianyuerrr/PicGo/main/img/202110010936468.png" alt="mysql引擎区别"></p>
<h2 id="三范式">三范式</h2>
<ul>
<li>1NF：原子性</li>
<li>2NF：不存在部分依赖（e.g. A, B, C, D；B依赖A，D依赖C）</li>
<li>3NF：不存在传递依赖（e.g. A, B, C；B依赖A，C依赖B）</li>
</ul>
<h2 id="文件系统与数据库">文件系统与数据库</h2>
<p><strong>区别</strong>在于：</p>
<p>(1)文件系统用文件将数据长期保存在外存上，数据库系统用数据库统一存储数据。</p>
<p>(2)文件系统中的程序和数据有一定的联系，数据库系统中的程序和数据分离。</p>
<p>(3)文件系统用操作系统中的存取方法对数据进行管理，数据库系统用DBMS统一管理和控制数据。</p>
<p>(4)文件系统实现以文件为单位的数据共享，数据库系统实现以记录和字段为单位的数据共享。</p>
<p>其<strong>联系</strong>在于：</p>
<p>(1)均为数据组织的管理技术。</p>
<p>(2)均由数据管理软件管理数据，程序与数据之间用存取方法进行转换。</p>
<p>(3)数据库系统是在文件系统的基础上发展而来的。</p>
<h2 id="语句执行顺序">语句执行顺序</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">(8) SELECT (9)DISTINCT&lt;Select_list&gt;<br>(1) FROM &lt;left_table&gt; (3) &lt;join_type&gt;JOIN&lt;right_table&gt;<br>(2) ON&lt;join_condition&gt;<br>(4) WHERE&lt;where_condition&gt;<br>(5) GROUP BY&lt;group_by_list&gt;<br>(6) WITH &#123;CUBE|ROLLUP&#125;<br>(7) HAVING&lt;having_condtion&gt;<br>(10) ORDER BY&lt;order_by_list&gt;<br>(11) LIMIT&lt;limit_number&gt;<br></code></pre></td></tr></table></figure>
<h2 id="索引">索引</h2>
<p><img src="https://raw.githubusercontent.com/xianyuerrr/PicGo/main/img/202110010935533.png" alt="mysql索引"></p>
<p><img src="https://raw.githubusercontent.com/xianyuerrr/PicGo/main/img/202110010934316.png" alt="mysql索引失效"></p>
<p>索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而<strong>不必扫描整个数据库</strong>。</p>
<p><strong>唯一性索引和复合索引</strong></p>
<ol>
<li>唯一性索引：保证在索引列中的全部数据是唯一的，不会包含冗余数据。</li>
<li>复合索引：一个索引创建在两个列或者多个列上。</li>
</ol>
<p><strong>聚簇索引与非聚簇索引</strong></p>
<ol>
<li>聚簇索引：数据表的物理顺序与索引顺序相同</li>
<li>非聚簇索引：数据表的物理顺序与索引顺序不相同</li>
</ol>
<p><strong>优点</strong></p>
<p>① 创建唯一性索引可以保证行的<strong>唯一性</strong></p>
<p>② <strong>大大加快数据的检索速度</strong></p>
<p>③ 建立索引可以<strong>加快表与表之间的连接</strong>，在实现数据的参考完整性方面特别有意义</p>
<p>④ <strong>加快分组和排序</strong></p>
<p><strong>缺点</strong></p>
<p>① 创建索引和维护索引需要<strong>时间成本</strong>，这个成本随着数据量的增加而加大</p>
<p>② 创建索引和维护索引需要<strong>空间成本</strong>，每一条索引都要占据数据库的物理存储空间，数据量越大，占用空间也越大（数据表占据的是数据库的数据空间）</p>
<p>③ 每次增删改索引需要进行<strong>动态维护</strong>，会<strong>降低表的增删改的效率</strong></p>
<p><strong>应该在这些列上创建索引</strong></p>
<ol>
<li>经常需要搜索、排序、使用Where的列上，加快搜索速度</li>
<li>作为主键的列上，强制该列的唯一性</li>
<li>经常用在连接的列上（主要是一些外键），可以加快连接的速度</li>
</ol>
<p><strong>什么情况下需要建立索引</strong></p>
<ol>
<li>数据量大的，更新频率较低，经常进行查询操作的表要建立索引。</li>
<li>用于排序的字段可以添加索引，用于分组的字段应当视情况看是否需要添加索引。</li>
<li>表与表连接用于多表联合查询的约束条件的字段应当建立索引。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/xianyuerrr/PicGo/main/img/202110031520036.png" alt="mysql优化WHERE子句"><img src="https://raw.githubusercontent.com/xianyuerrr/PicGo/main/img/202110031520036.png" alt="mysql优化WHERE子句"></p>
<h2 id="为什么索引使用B-树而不是B树">为什么索引使用B+树而不是B树</h2>
<p>B树：是特殊的平衡N叉树。</p>
<p>（1）每个节点最多有m个分支，如果是根节点且不是叶子结点，分枝数最少为2个；非根非叶子结点分枝数最少为m/2个。</p>
<p>（2）有n个分支的节点，就有n-1个关键字，关键字互不相等。</p>
<p>（3）关键字把子节点划分成一个个区间</p>
<p>（4）所有的叶子结点处于同一层</p>
<p>（5）新加节点和删除节点可能会进行树节点的合并和分裂。</p>
<p>B树的每一个节点都包含key和value，如果经常访问的元素离根节点很近，访问会很迅速。</p>
<p>B+树</p>
<p>（1）有k个子节点的节点必然有k个关键码。</p>
<p>（2）非叶子结点只有索引作用，跟数据有关的信息均存放在叶子结点上</p>
<p>（3）树的所有叶子结点构成一个双向有序链表，可以按照关键码的排序次序遍历所有记录。</p>
<p>B+树的内部节点没有指向关键字具体信息的指针，所以内部节点更小；如果把所有同一内部节点的关键字存在同一个盘块中，那么盘块所能容纳的关键字数量也就更多，一次性读入内存中需要查找的关键字也就更多，减少了IO读写次数。</p>
<p>B+树的叶子结点是相连的，因此对整棵树的遍历只需要一次线性遍历叶子结点就可以了。便于区间搜索和查找。</p>
<h2 id="窗口函数">窗口函数</h2>
<p>原则上只能写在select子句中</p>
<p><strong>group by分组汇总后改变了表的行数，一行只有一个类别。而partiition by和rank函数不会减少原表中的行数</strong></p>
<p>聚合函数sum在窗口函数中，是<strong>对自身记录、及位于自身记录以上</strong>的数据进行求和的结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;窗口函数&gt; over (partition by &lt;用于分组的列名&gt; order by &lt;用于排序的列名&gt;)<br></code></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/xianyuerrr/PicGo/main/img/20210816171827.png" alt="img"></p>
<p><strong>经典TOPN问题</strong>：找出每个部门工资排名前N的员工</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">select *<br>from（select*，row_number() over (partition by 部门 order by salary desc) as ranking<br>from 表名) as a<br>where ranking&lt;=N;<br></code></pre></td></tr></table></figure>
<h2 id="事务">事务</h2>
<p>是用户定义的一系列数据库操作，这些操作可以视为一个完成的逻辑处理工作单元，要么全部执行，要么全部不执行，是不可分割的工作单元。</p>
<p><strong>ACID</strong></p>
<p>原子性（要么都成功，要么都失败）、一致性（一致性状态变到另一个一致性状态）、隔离性（事务不能互相干扰）、持久性（改变是永久性的，写入磁盘）</p>
<p><strong>常见问题</strong></p>
<p>脏读：（读未提交）B读到了A<strong>修改但未提交</strong>的数据，但之后A因为回滚或者只是作为一个中间过程未提交</p>
<p>不可重复读：B多次读取同一个数据，但由于A对于此数据进行了修改，导致B的连续两次读取结果不一样</p>
<p>幻读：B多次查询数据库，A在B查询的间隔进行了数据的插入或删除，导致B的查询结果发生了变化，像幻觉一样</p>
<p><strong>隔离级别</strong></p>
<p>读未提交：事务修改的数据还未提交时，<strong>变化</strong>就能被其他事务读到</p>
<p>读提交：事务修改的数据提交之后，<strong>变化</strong>才能被其他事务读到</p>
<p>可重复读：事务执行过程中看到的数据，<strong>与事务启动时看到的结果一致</strong>，不会改变。当然自身未提交的变化其他事务也是读不到的</p>
<p>串行化：读写会加锁，出现冲突时，<strong>只能等前一个事务执行完毕</strong>才能执行</p>
<p><strong>MVCC</strong></p>
<p>多版本并发控制，是数据库控制并发访问的一种手段</p>
<p>只在 <strong>读已提交(RC)</strong> 和 <strong>可重复度（RR）</strong> 这两种事务隔离级别下才有效</p>
<h2 id="视图">视图</h2>
<p>是虚拟的表，本身不包含数据，也就不能对其进行索引操作。</p>
<p>对视图的操作和对普通表的操作一样。</p>
<p>视图具有如下好处：</p>
<ul>
<li>简化复杂的 SQL 操作，比如复杂的连接；</li>
<li>只使用实际表的一部分数据；</li>
<li>通过只给用户访问视图的权限，保证数据的安全性；</li>
<li>更改数据格式和表示。</li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>正向代理与反向代理</title>
    <url>/2021/09/01/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h2 id="正向代理与反向代理">正向代理与反向代理</h2>
<h3 id="正向代理">正向代理</h3>
<p>正向代理：代理客户端。位于客户端和目标服务器之间的服务器(代理服务器)，为了从目标服务器取得内容，客户端向代理服务器发送一个请求并指定目标，然后代理服务器向目标服务器转交请求并将获得的内容返回给客户端。</p>
<p><img src="https://raw.githubusercontent.com/xianyuerrr/PicGo/main/img/202110041533305.png" alt="image-20211004153346161"></p>
<p>正向代理的作用：</p>
<ol>
<li>突破访问限制</li>
<li>提高访问速度</li>
<li>隐藏客户端真实IP</li>
</ol>
<h3 id="反向代理">反向代理</h3>
<p>反向代理：代理服务端的。代理服务器接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端</p>
<p><img src="https://raw.githubusercontent.com/xianyuerrr/PicGo/main/img/202110041535449.png" alt="image-20211004153557367"></p>
<p>反向代理的作用：</p>
<ol>
<li>隐藏服务器IP</li>
<li>负载均衡</li>
<li>提高访问速度</li>
<li>提供安全保障</li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>计网 - 面试</tag>
      </tags>
  </entry>
  <entry>
    <title>水塘抽样，相等概率随机取数</title>
    <url>/2022/04/25/%E6%B0%B4%E5%A1%98%E6%8A%BD%E6%A0%B7%EF%BC%8C%E7%9B%B8%E7%AD%89%E6%A6%82%E7%8E%87%E9%9A%8F%E6%9C%BA%E5%8F%96%E6%95%B0/</url>
    <content><![CDATA[<h1>水塘抽样，相等概率随机取数（不定长数据流）</h1>
<p>问题描述：设 $ nums $ 中有 $ k $ 个值为 $ target $ 的元素，保证这 $ k $ 个值成为返回值的概率均为 $ \frac{1}{k} $</p>
<p>操作：遍历 $ nums $，当我们第 $ i $ 次遇到值为 $ target $ 的元素时，随机选取 $ [0,i) $ 内的一个整数，如果其等于 $ 0 $ (范围内任何值都可)，那么就将返回值置为该元素下标，否则不变。</p>
<p>证明：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26P%28%E7%AC%AC%20i%20%E6%AC%A1%E9%81%87%E5%88%B0%E5%80%BC%E4%B8%BA%20target%20%E7%9A%84%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%8B%E6%A0%87%E6%88%90%E4%B8%BA%E6%9C%80%E7%BB%88%E8%BF%94%E5%9B%9E%E5%80%BC%29%20%5C%5C%0A%26%3D%20P(%E7%AC%AC%20i%20%E6%AC%A1%E9%9A%8F%E6%9C%BA%20%3D%200)%20%5Ctimes%20P(%E7%AC%AC%20i%2B1%20%E6%AC%A1%E9%9A%8F%E6%9C%BA%20!%3D%200)%20%5Ctimes%20%5Cldots%20%5Ctimes%20P(%E7%AC%AC%20k%20%E6%AC%A1%E9%9A%8F%E6%9C%BA%20!%3D%200)%20%5C%5C%0A%26%20%3D%20%5Cfrac%7B1%7D%7Bi%7D%20%5Ctimes%20(1%20-%20%5Cfrac%7B1%7D%7Bi%2B1%7D)%20%5Ctimes%20%5Cldots%20(1%20-%20%5Cfrac%7B1%7D%7Bk%7D)%20%5C%5C%0A%26%20%3D%20%5Cfrac%7B1%7D%7Bi%7D%20%5Ctimes%20%5Cfrac%7Bi%7D%7Bi%2B1%7D%20%5Ctimes%20%5Cldots%20%5Ctimes%20%5Cfrac%7Bk-1%7D%7Bk%7D%20%5C%5C%0A%26%20%3D%20%5Cfrac%7B1%7D%7Bk%7D%0A%5Cend%7Baligned%7D%0A" /></p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>):</span><br>        self.root = head<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getRandom</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        node, ans, i = self.root, <span class="hljs-literal">None</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> node:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> randint(<span class="hljs-number">0</span>, i):<br>                ans = node.val<br>            node, i = node.<span class="hljs-built_in">next</span>, i + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>随机</tag>
      </tags>
  </entry>
  <entry>
    <title>注解</title>
    <url>/2018/12/02/%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h1>注解</h1>
<p>Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。</p>
<p>Java 语言中的类、方法、变量、参数和包等都可以被标注。</p>
<p>可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容 。 也支持自定义 Java 标注。</p>
<h2 id="元注解">元注解</h2>
<ol>
<li>@Retention ： 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</li>
<li>@Documented ： 标记这些注解是否包含在用户文档中。</li>
<li>@Target ： 标记这个注解应该是哪种 Java 成员。</li>
<li>@Inherited ： 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)</li>
</ol>
<h2 id="说明">说明</h2>
<ol>
<li>Annotation 就是个接口</li>
<li>ElementType 是 Enum 枚举类型，它用来指定 Annotation 的类型</li>
<li>RetentionPolicy 是 Enum 枚举类型，它用来指定 Annotation 的策略。通俗点说，就是不同 RetentionPolicy 类型的 Annotation 的作用域不同</li>
</ol>
<h2 id="作用">作用</h2>
<ol>
<li>编译检查（比如 <code>@Override</code>）</li>
<li>在反射中使用</li>
<li>生成帮助文档</li>
</ol>
<p><img src="https://raw.githubusercontent.com/xianyuerrr/PicGo/main/img/20210921103330.png" alt="image-20210921103323677"></p>
<p><strong>Annotation.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.lang.annotation;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Annotation</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>;<br><br>    Class&lt;? extends Annotation&gt; annotationType();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>ElementType.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.lang.annotation;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ElementType</span> </span>&#123;<br>    TYPE,               <span class="hljs-comment">/* 类、接口（包括注释类型）或枚举声明  */</span><br><br>    FIELD,              <span class="hljs-comment">/* 字段声明（包括枚举常量）  */</span><br><br>    METHOD,             <span class="hljs-comment">/* 方法声明  */</span><br><br>    PARAMETER,          <span class="hljs-comment">/* 参数声明  */</span><br><br>    CONSTRUCTOR,        <span class="hljs-comment">/* 构造方法声明  */</span><br><br>    LOCAL_VARIABLE,     <span class="hljs-comment">/* 局部变量声明  */</span><br><br>    ANNOTATION_TYPE,    <span class="hljs-comment">/* 注释类型声明  */</span><br><br>    PACKAGE             <span class="hljs-comment">/* 包声明  */</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>RetentionPolicy.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.lang.annotation;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">RetentionPolicy</span> </span>&#123;<br>    SOURCE,            <span class="hljs-comment">/* Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了  */</span><br><br>    CLASS,             <span class="hljs-comment">/* 编译器将Annotation存储于类对应的.class文件中。默认行为  */</span><br><br>    RUNTIME            <span class="hljs-comment">/* 编译器将Annotation存储于class文件中，并且可由JVM读入 */</span><br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 Maven 在 IDEA 总是自动使用 1.5 版本</title>
    <url>/2021/01/06/%E8%A7%A3%E5%86%B3-Maven-%E5%9C%A8-IDEA-%E6%80%BB%E6%98%AF%E8%87%AA%E5%8A%A8%E4%BD%BF%E7%94%A8-1-5-%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<h1>解决IDEA maven 老是自动使用JDK1.5的问题</h1>
<img src="https://cdn.jsdelivr.net/gh/xianyuerrr/PicGo/img/202110011611542.png" alt="image-20211001161153403" style="zoom:50%;" />
<img src="https://cdn.jsdelivr.net/gh/xianyuerrr/PicGo/img/202110011613048.png" alt="image-20211001161332973" style="zoom: 50%;" />
<p>如上图，一使用Maven这些module就自动使用 JDK1.5，</p>
<p>项目结构里 Language Level 也都自动变成了 5。很烦，一运行就会出现以下 Messages：</p>
<img src="https://cdn.jsdelivr.net/gh/xianyuerrr/PicGo/img/202110011615495.png" alt="image-20211001161512457" style="zoom: 67%;" />
<p>被这个东西烦到不行，于是乎进行了各种尝试，最终解决了问题。</p>
<p>我们对 Maven 的配置文件进行更改就可以了。</p>
<p>我们找到 Maven 的用户配置文件（就是下图标出的路径下的文件）并打开。</p>
<img src="https://cdn.jsdelivr.net/gh/xianyuerrr/PicGo/img/202110011617970.png" alt="image-20211001161717900" style="zoom: 50%;" />
<p>然后在 <code>&lt;settings&gt; &lt;/settings&gt;</code> 标签内添加如下内容，即可将对应版本都更改为 JDK1.8：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>jdk-1.8<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">jdk</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">jdk</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 pip 更新失败的问题</title>
    <url>/2020/12/26/%E8%A7%A3%E5%86%B3-pip-%E6%9B%B4%E6%96%B0%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1>pip更新失败找不到</h1>
<h2 id="问题描述">问题描述</h2>
<p>当我们的pip版本不够新的时候，安装完库会出现下图的情况：</p>
<p><img src="https://img-blog.csdnimg.cn/20201226110404933.png" alt="image-20201226104158100"></p>
<p>我们可以执行下面的命令去更新pip：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">pip install --upgrade pip<br></code></pre></td></tr></table></figure>
<p>但是烦人的是，有时更新会出错，比如下图的错误：</p>
<p><img src="https://img-blog.csdnimg.cn/2020122611042436.png" alt="image-20201226104458073"></p>
<p>在卸载旧版本的pip之后，出现了拒绝访问的错误，然后新版本的pip没安装成功。当我们再想使用pip的时候，就会出现下图的情况：</p>
<p><img src="https://img-blog.csdnimg.cn/20201226110436897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODc0ODM0,size_16,color_FFFFFF,t_70" alt="image-20201226104653406"></p>
<p>显示“No module named ‘pip’”，由于旧的卸载了，新的还没装上去，所以pip已经没了。</p>
<h2 id="解决方法">解决方法</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">python -m ensurepip<br>python -m pip install --upgrade pip<br></code></pre></td></tr></table></figure>
<p>执行第一句之后：</p>
<p><img src="https://img-blog.csdnimg.cn/20201226110447479.png" alt="image-20201226105041459"></p>
<p>执行第二句之后：</p>
<p><img src="https://img-blog.csdnimg.cn/20201226110456416.png" alt="image-20201226105110442"></p>
<p>完成！</p>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>pip</tag>
      </tags>
  </entry>
</search>
